<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[原型-原型链-继承]]></title>
      <url>%2F2017%2F01%2F07%2F%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[原型的概念 概念：所谓原型就是指 函数的prototype属性所引用的对象 只要定义一个函数，那么就会创建其原型 由上述函数创建出来的所有对象，都可以直接访问到原型上的成员 作用：实现同类对象之间的数据共享。 获取原型方式 通过函数：.prototype 通过对象：.__proto__ 注意：已__开头和结尾的属性均为非标准属性; 原型 默认具有constructor属性，引用的就是其构造函数 原型特性： 动态性 在已有的原型上扩展成员，直接反映到已创建出来的对象上。 如果置换了已有的原型，那么会反映到后面新创建的对象，而不会影响之前创建的对象 唯一性 由同一个构造函数创建出来的所有对象，都共享一个原型。 不可变性 不能通过对象来修改原型上的成员 共享性 所有的对象都可以直接访问其原型上的成员 原型链 原型链的概念 所谓原型链 就是指 从一个对象到Object.prototype之间存在一条体现继承层次关系的链式结构，这个结构被称为对象的原型链。 本质：链上的每一个对象都是通过__proto__属性连接起来的。 绘制原型链 先简写对象的原型链 将上述原型链上的所有对象绘制在图形上。并且将和原型链相关的属性添加到对象上。 给对象的每一个属性确定指向 如果在图形上的每一个对象的属性都有正确指向，说明绘制完成。 相关结论： Object.prototype的原型为null 默认原型对象的原型为Object.prototype Object.prototype 的部分常用方法简介 hasOwnProperty has 有 own 自己的 property 属性 语法：obj.hasOwnProperty(“propName”) 用来判断指定属性是否为对象自身的，而不是继承过来的;如果是自身的就返回true，否则返回false isPrototypeOf is 是 Prototype 原型 of 的 obj1.isPrototypeOf(obj2) 用来判断obj1 对象 是否为 obj2对象 的原型；如果是，就返回true，否则返回false。 propertyIsEnumerable property 属性 is 是 Enumerable 可枚举的 可以使用for in遍历出来的属性 obj.propertyIsEnumerable(‘propName’) hasOwnProperty升级版： 满足这2个条件返回true，否则返回false 指定的属性必须是对象本身的 该属性必须可枚举 12345678910111213141516171819202122232425var o = &#123;name: 'tom'&#125;;console.log(o.toString()); //[object Object]// 1：hasOwnPropertyconsole.log(o.hasOwnProperty('constructor'));// false console.log(o.hasOwnProperty('name')); // true// 2：isPrototypeOfconsole.log(Object.prototype.isPrototypeOf(o)); // trueconsole.log(o.isPrototypeOf(Object.prototype)); // false// 3：propertyIsEnumerablefor(var k in o)&#123; console.log(k); //name&#125;console.log(o.propertyIsEnumerable('__proto__')); //falseObject.prototype.age = 18;for( k in Object.prototype )&#123; console.log(k); //age&#125;console.log(o.propertyIsEnumerable('age')); //falsefunction foo() &#123; console.log(this); //Number&#125;foo.call(1); 装箱 与 拆箱 将基本数据类型 装换为 复合数据类型，这个过程被称为 装箱 将复合数据类型 装换为 基本数据类型，这个过程被称为 拆箱 强调几点 默认原型对象才具有constructor属性 只有函数具有prototype属性（除了Function.prototype） 任意的对象都具有__proto__属性 instanceof介绍 obj instanceof constructor 规则：如果constructor 的原型 出现在 obj 的原型链上的话，表达式返回值为true，否则false。 12345678910111213var o = &#123;name: 'tom'&#125;;function parent() &#123;&#125;function child() &#123;&#125;var o = Object.create(parent.prototype);// console.log(o.constructor);child.prototype = o;// 手动添加constructor属性，并复制为child构造函数。child.prototype.constructor = child;var c = new child;console.log(c instanceof parent); //true// c -&gt; o -&gt; parent.prototype -&gt; Object.prototype -&gt; null 继承 注意：其他面向对象语言 C# Java swift 类与类之间继承,而在js中，是对象与对象之间的继承 概念：就是指 一个对象有权去访问另一个对象上的成员（属性和方法） 继承的方式 先定义一个父类 12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + '正在吃：' + food);&#125;; 原型链 思想:借助原型可以基于已有的对象创建新对象,将子类的原型指向父类的实例 123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat'; // Test Codevar cat = new Cat();console.log(cat.name);//cat console.log(cat.eat('fish'));//cat正在吃fishconsole.log(cat.sleep());//cat正在睡觉!console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点 字面量重写原型会中断关系 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参ECMAScript5通过新增Object.create()方法规范化了原型式继承，这个方法接收两个参数：一个用作新对象原型的对象和一个作为新对象定义额外属性的对象。 构造继承 思想:使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 12345678910function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);// Tomconsole.log(cat.sleep());// Tom正在睡觉!console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承 思想:为父类实例添加新特性，作为子类实例返回 123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);// Tomconsole.log(cat.sleep());// Tom正在睡觉!console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 拷贝继承 1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承 思想:通过调用父类构造函数，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 123456789101112function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了,多消耗了一点内存） 寄生组合继承 思想:通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 123456789101112131415161718function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点： 堪称完美 缺点： 实现较为复杂 123456789101112131415161718192021222324252627282930313233343536373839function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125; //实例引用属性 this.features = [];&#125;function Cat(name)&#123;&#125;Cat.prototype = new Animal();var tom = new Cat('Tom');var kissy = new Cat('Kissy');console.log(tom.name); // "Animal"console.log(kissy.name); // "Animal"console.log(tom.features); // []console.log(kissy.features); // []tom.name = 'Tom-New Name';tom.features.push('eat');//针对父类实例值类型成员的更改，不影响console.log(tom.name); // "Tom-New Name"console.log(kissy.name); // "Animal"//针对父类实例引用类型成员的更改，会通过影响其他子类实例console.log(tom.features); // ['eat']console.log(kissy.features); // ['eat']/*原因分析：关键点：属性查找过程执行tom.features.push，首先找tom对象的实例属性（找不到） 那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的features属性中插入值 在console.log(kissy.features)的时候。同上，kissy实例上没有，那么去原型上找 刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了*/ 属性搜索原则：当访问对象的某个属性时， 首先，在对象本身上查找，如果找到就返回值，并停止查找； 如果没有找到就向其原型对象上查找，如果找到就返回值，并停止查找； 如果在没有找到，就继续向其原型的原型对象上查找，直到Object.prototype 此时如果找到就返回值，否则值为undefined。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[requireJS作用和用法]]></title>
      <url>%2F2017%2F01%2F06%2FrequireJS%2F</url>
      <content type="text"><![CDATA[requireJS的需求 需求: 在一个网页有大量的js需要加载的时候,传统方式就是用大量的script标签依次加载. 1234567//举个栗子&lt;script src="1.js"&gt;&lt;/script&gt;&lt;script src="2.js"&gt;&lt;/script&gt;&lt;script src="3.js"&gt;&lt;/script&gt;&lt;script src="4.js"&gt;&lt;/script&gt;&lt;script src="5.js"&gt;&lt;/script&gt;&lt;script src="6.js"&gt;&lt;/script&gt; 缺点 首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长 其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难 requireJS作用 实现js文件的异步加载，避免网页失去响应 管理模块之间的依赖性，便于代码的编写和维护 使用requireJS 加载requireJS 1&lt;script src="js/require.js"&gt;&lt;/script&gt; 加载这个文件，也可能造成网页失去响应 解决办法: 一个是把它放在网页底部加载 见下面代码 1 &lt;script src="js/require.js" defer async="true" &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 加载主模块data-main 指定网页程序的主模块。这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 1 &lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 主模块类似于入口函数,也就是所有代码必须先经过它 main.js的写法 如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码 123//main.jsalert('加载成功')//这种情况不需要requireJS 一般来说,主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。 1234// main.jsrequire(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC)&#123;// some code here&#125;); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’,’moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 12345//假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123;// some code here&#125;);//require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。 模块加载 假如主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。 使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部(或者通过script标签先后加载require.js和require.config.js).参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。 模块与main.js在同一个目录下的加载方式 1234567require.config(&#123; paths: &#123; "jquery": "jquery.min", "underscore": "underscore.min", "backbone": "backbone.min" &#125;&#125;); 模块在其他目录 1234567891011121314151617//比如js/lib目录，main.js在js目录下,则有两种写法。一种是逐一指定路径require.config(&#123; paths: &#123; "jquery": "lib/jquery.min", "underscore": "lib/underscore.min", "backbone": "lib/backbone.min" &#125;&#125;);//另一种则是直接改变基目录（baseUrl）require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": "jquery.min", "underscore": "underscore.min", "backbone": "backbone.min" &#125;&#125;); 模块在另一台主机上 123456//可以直接指定它的网址，比如：require.config(&#123; paths: &#123; "jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min" &#125;&#125;); 注意:如果加载模块的标识名称中含有.js则相对于当前页面的url路径去查找,一般来说,最好paths和require的时候都不要加.js AMD模块的写法 require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写. 具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 不依赖其他的模块 123456789// math.jsdefine(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;;&#125;); 12345//加载模块// main.jsrequire(['math'], function (math)&#123; alert(math.add(1,1));&#125;); 依赖其他模块的模块加载 123456789101112131415161718192021//define()函数的第一个参数，必须是一个数组，指明该模块的依赖性define(['myLib'], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;;&#125;);//当require()函数加载上面这个模块的时候，就会先加载myLib.js文件//或者也可以这样写define(function(myLib)&#123; var $ = require('myLib') function foo()&#123; $.doSomething(); &#125; return &#123; foo : foo &#125;;&#125;); 加载非规范的模块 require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合 加载方式:在用require()加载之前，要先用require.config()方法，定义它们的一些特征 1234567891011121314151617require.config(&#123; shim: &#123; 'underscore':&#123; exports: '_' &#125;, 'backbone': &#123; deps: ['underscore', 'jquery'], exports: 'Backbone' &#125; &#125;&#125;);// 对于所有有依赖的插件来说：// 1. 先在 paths 中配置该插件的标识及路径// 2. 在 shim 中，手动给该插件声明依赖项// 3. 使用的时候，只需要通过 paths 中配置的插件名称加载就可以了，它会自动去找依赖项// 如果有对外暴露的接口，则直接使用就可以了// 如果是类似于 jQuery 插件的东西，就直接加载就可以了，没有暴露的接口对象 require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义 exports值（输出的变量名），表明这个模块外部调用时的名称,针对那些老旧的，没有按照AMD规范声明的代码，把他们暴露在window下的对象名，映射到key上去。 deps数组，表明该模块的依赖性。 建议的写法 12//先用script标签加载require.js data-main类似于入口函数会紧跟着加载&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 123456789101112131415161718192021//data-main里面的写法require.config(&#123;//设置基础路径,以后require的路径前面都会加上baseUrl的内容 baseUrl: '/public', paths: &#123; underscore: '/node_modules/underscore/underscore', jQuery.lazyload: '/node_modules/jQuery.lazyload/jQuery.lazyload', jquery: '/node_modules/jquery/dist/jquery', &#125;, shim: &#123; //设置依赖项和对外暴露的符号 //如果有对外暴露的接口，则直接使用就可以了,不需要export的时候建议不写 jQuery.lazyload:&#123; deps:['jquery'], &#125; &#125;&#125;)//需要require的时候,去找paths里面定义的名字,建议形参用该模块对外暴露的id去接收,参照习惯比较方便,当然你用@去接收jQuery在回调函数里面也需要@()来获取元素require(['jquery', 'underscore', 'jQuery.lazyload'], function ($, _, lazy)&#123;// some code here&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象:词法作用域-作用域-作用域链]]></title>
      <url>%2F2017%2F01%2F05%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
      <content type="text"><![CDATA[词法作用域 概念: 词法作用域规定变量的作用是在定义时，而不是在执行时决定的 没有块级作用域 只有函数可以限定作用域 全局变量 不在任何函数内定义的变量(或者隐式全局) 在任何位置都可以被访问到 局部变量 在函数内部定义的变量（包括参数声明） 只有在函数内部可以被访问到 作用域链 作用域种类 弱类型语言：大部分为 静态作用域 强类型语言：动态作用域 变量的搜索原则： 当访问一个变量时，首先在当前作用域上查找，如果找到就直接使用，并停止查找； 如果没有找到，就会向上一级作用域上查找，如果找到就直接使用，并停止查找； 如果还没有找到就继续向上一级作用域查找，直到全局作用域，如果找到就直接使用，并停止查找； 否则报错（xxx is not defined.） 绘制作用域链的步骤 全局作用域 为 0 级链。将在当前作用域上的变量、对象等数据，绘制在该链上。 函数可以限定作用域，在绘制过程中，只要遇到函数，就在此基础上扩展一条新俩链，级别为 当前级别 + 1； 重复2步骤，直到所有函数都扩展出了新链为止。 在变量搜索的时候，如果访问的是全局变量，那么会搜索整个作用域链。性能会降低。在实际开发时，可以将常用的全局对象传入局部变量内。在同级链上的变量，互相不能访问。 示范:123456789101112131415var f = 1; function foo() &#123; var f = 2; console.log(f); // 2 function fn() &#123; var f = 3; console.log(f); // 3 &#125; function ffn() &#123; console.log(f); //2 &#125; fn(); ffn();&#125;foo();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript声明提升和作用域]]></title>
      <url>%2F2017%2F01%2F04%2FJavaScript%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%2F</url>
      <content type="text"><![CDATA[在es6里面已经可以规避了声明的提升,但在es6之前包括严格模式下都会遇见声明提升带来的一些问题 变量定义 可以使用var定义变量，变量如果没有赋值，那变量的初始值为undefined. 如果没有使用var定义,那么就是隐式全局变量,此时全局都可以获得该变量,其作用域为全局 变量作用域变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数内有效。在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。所有不使用var定义的变量都视为全局变量 变量运行（搜索）机制：首先看，有没有局部作用域如果有，查找是不是这个局部作用域定义的变量如果不是，寻找上一级作用域，直到找到全局作用域如果全局作用域也找不到这个变量，这个变量就是未定义的 undefined 函数作用域和声明提前JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说变量在声明之前已经可用，所有这特性称为声明提前（hoisting），即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。如下面例子：注释：声明提前是在JavaScript引擎的预编译时进行，是在代码开始运行之前。123456var scope = 'global';function f()&#123; console.log(scope); var scope = 'local'; console.log(scope);&#125; 由于函数内声明提升，所以上面的代码实际上是这样的1234567var scope = 'global';function f()&#123; var scope; //变量声明提升到函数顶部 console.log(scope); scope = 'local'; //变量初始化依然保留在原来的位置 console.log(scope);&#125; 变量声明 VS 函数声明 一般情况下,函数声明会覆盖变量声明。 但是如果在变量声明的同时，对变量进行初始化，情况会有所不同。对同一个变量名，声明变量同时初始化变量优先级高于函数声明。 12345var a = 1;function a() &#123; return true; &#125; console.log(a); //1 12345var a;function a()&#123; return true;&#125;console.log(a) //此时打印的是a的函数体 结论 变量声明提升：变量申明在进入执行上下文就完成了。 只要变量在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部； 函数声明提升：执行代码之前会先读取函数声明，意味着可以把函数声明放在调用它的语句后面。 只要函数在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部； 变量or函数声明：函数声明会覆盖变量声明，但不会覆盖变量赋值.同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。注意：如果在变量声明的同时初始化a，或是之后对a进行赋值，此时a的值变量的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器同源策略和跨域问题]]></title>
      <url>%2F2017%2F01%2F03%2F%E8%B7%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[同源策略所谓同源策略，指的是浏览器对不同源的脚本或者文本的访问方式进行的限制。比如源a的js不能读取或设置引入的源b的元素属性。 同源:URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。 一个网站的网址组成包括协议名，子域名，主域名，端口号。比如https://www.github.com/80，其中https是协议名，www是子域名，github是主域名，端口号是80，当在在页面中从一个url请求数据时，如果这个url的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域问题。即使是在 http://localhost:80/ 页面请求 http://127.0.0.1:80/ 也会有跨域问题（因为域名不一样） PS：浏览器中的file://域拥有的权限很高，WebKit可以读取磁盘上的文件，IE可以执行CMD 特别注意两点：一.如果是协议和端口造成的跨域问题“前台”是无能为力的二.在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。（跨域限制是浏览器行为，不是服务器行为) 另外同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、image等仍然认为属于同源。 跨域的方法 jsonp - 动态创建script标签实现跨域浏览器的script、img、iframe标签是不受同源策略限制的 ，所以通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的callback函数，并把把我们需要的json数据作为参数传入。在服务器端，当req.params参数中带有callback属性时，则把数据作为callback的参数执行，并拼接成一个字符串后返回。创建一个新的script标签，并插入DOM中，浏览器会像载入页面本身的script标签一样载入和运行插入标签的源文件。新script标签的源文件包含了一个页面本身已存在的一个JavaScript函数的调用，当执行这个源文件时，也会执行已存在的函数，这一过程定义了一个回调函数的方法。实际的jsonp接口中，会让你传一个函数名过去，然后返回的数据中回调函数名就是你传的函数名，回调函数的参数则是封装的json格式。jQuery中的jsonp实现原理基本就是这样 例子:第一个是http://www.foo.com/jsonp.html，通过动态创建script标签加载了http://www.bar.com/js/outer.js文件.然后outer.js文件返回的内容正好是一个函数调用，就会执行这个函数.如此，实现了数据传递和回调过程 1234567891011121314151617# jsonp.html&lt;script type="text/javascript"&gt;function callback(data) &#123; alert(data.message);&#125;function addScriptTag(src)&#123;var script = document.createElement('script'); script.src = src; document.body.appendChild(script);&#125;window.onload = function()&#123; addScriptTag("http://www.foo.com/js/outer.js");&#125;&lt;/script&gt;# outer.jscallback(&#123;message:"success"&#125;); 判断script节点加载完毕：IE只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。 123456js.onload = js.onreadystatechange = function() &#123; if (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') &#123; // callback在此处执行 js.onload = js.onreadystatechange = null; &#125; &#125;; 优点：兼容性好，在很古老的浏览器中也可以用，简单易用，支持浏览器与服务器双向通信。 缺点 只支持GET请求(因为基于script)且只支持跨域HTTP请求这种情况（不支持HTTPS) 安全问题(请求代码中可能存在安全隐患) 要确定jsonp请求是否失败并不容易 CORS跨域 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10 CORS请求分成两类：简单请求（simple request）和非简单请求 简单请求: 12345678910（1) 请求方法是以下三种方法之一： HEAD GET POST（2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段. Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。也解决了jsonp里面post不能跨域的问题 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 更多详情见阮一峰博客 例子: 启动nodejs web应用的app.js 1234567var express = require("express"); var http = require("http"); var app = express(); var router = express.Router(); var testRouter = require('./routes/test/test'); app.use('/test', testRouter); http.createServer(app).listen(3000); 处理具体api的控制器 test.js 1234567891011121314151617181920212223var express = require('express'); var router = express.Router(); /* GET home page. */ router.get('/', function(req, res, next) &#123; res.render('index', &#123; name: 'Express 路由1' &#125;); &#125;); /* GET home page. */ router.get('/cors', function(req, res, next) &#123; res.render('test/index', &#123; name: 'Express 路由1' &#125;); &#125;); /* GET home page. */ router.get('/getData', function(req, res, next) &#123; //设置允许跨域请求 var reqOrigin = req.header("origin"); if(reqOrigin !=undefined &amp;&amp; reqOrigin.indexOf("http://localhost:3000") &gt; -1)&#123; //设置允许 http://localhost:3000 这个域响应 res.header("Access-Control-Allow-Origin", "http://localhost:3000"); res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.header("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"); &#125; res.json(200, &#123;name:"张三1",age:40&#125;); &#125;); module.exports = router; 模板页面，发送ajax跨域请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;script src="../public/js/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="../public/js/hb_common.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="../public/css/bootstrap.min.css"&gt; &lt;link rel="stylesheet" href="../public/css/hb_wap.css"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body &gt; &lt;button class="btn btn-primary" id="btn" onclick="corsGetData()"&gt;cors跨域获取数据&lt;/button&gt; &lt;br&gt; &lt;button class="btn btn-primary" id="btn4" onclick="getData()"&gt;不跨域获取数据&lt;/button&gt; &lt;br&gt; &lt;/body&gt; &lt;script&gt; function getData()&#123; $.ajax(&#123; url: "http://localhost:3000/test/getData", type:"GET", cache: false, success: function(html)&#123; alert(html); $("#results").append(html); &#125; &#125;) &#125; function corsGetData()&#123; $.ajax(&#123; url: "http://www.huangbiao.com:3000/test/getData", type:"GET", cache: false, success: function(html)&#123; alert(html); $("#results").append(html); &#125; &#125;) &#125; &lt;/script&gt; &lt;/html&gt; 特点: CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。 JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 代理跨域nodeJS实现代理原理:我们在127.0.0.1:5000/index.html下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如127.0.0.1:5000/api/products,然后这个代理发送HTTP请求访问127.0.0.1:3000/api/products，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略限制），客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性 页面:向http://127.0.0.1:5000/api/products发起ajax请求 123456789//html页面部分js$.ajax(&#123; url:'/api/product', type:'get', dataType:'json', success:function(data)&#123; console.log(data) &#125;&#125;) 本地服务器: 1234567app.get('/', (req, res, next) =&gt; &#123; res.render('index.html')&#125;)app.listen(5000, () =&gt; &#123; console.log('running at port 5000...')&#125;) 接口代理:本地服务器在接受请求之后,将请求转发给http://127.0.0.1:3000/api/products本地服务器: 1234567891011app.get('/api/products', (req, res, next) =&gt; &#123; http.get('http://127.0.0.1:3000/api/products', proxyRes =&gt; &#123; let data = '' proxyRes.on('data', chunk =&gt; &#123; data += chunk &#125;) proxyRes.on('end', () =&gt; &#123; res.send(data) &#125;) &#125;)&#125;) api接口服务器:接收到请求之后,相应一个json格式的数据需要跨域的服务器: 12345678app.get('/api/products', (req, res, next) =&gt; &#123; res.send(&#123; success: true, ret: &#123; list: products &#125; &#125;)&#125;) 代理跨域常用的中间件http-proxy-middleware 作用：将当前网站所有的 /api 开头的请求都代理到 http://127.0.0.1:3000，代理是没有跨域限制的 你请求的时候，还是直接请求自己网站的 /api/** proxy 将你的请求代理到 http://127.0.0.1:3000 ，请求转发 proxy 将接收到的数据原封不动的响应给你的请求 1234//写了这个,上述接口代理,就是本地服务器的一段代码简化为这个//该中间件自动帮你处理//注意:除了端口的区别,其他必须一致,比如/api/productsapp.use(&apos;/api&apos;, proxy(&#123;target: &apos;http://127.0.0.1:3000&apos;, changeOrigin: true&#125;))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包概念应用以及相关问题(内存泄漏,垃圾回收)]]></title>
      <url>%2F2017%2F01%2F02%2F%E9%97%AD%E5%8C%85%E6%A6%82%E5%BF%B5%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[闭包的概念 闭包：指有权访问另一个函数作用域中的变量的函数。闭包的本质是将函数内部和函数外部连接起来的一座桥梁.在JavaScript中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后 如何创建闭包 12345678910function outer()&#123; var a=1; function inner()&#123; a++; alert(a); &#125; return inner;&#125;var f1=outer();//创建了一个闭包，f1能访问outer函数中的变量f1();//弹出2. 这段代码的特点在于： 函数inner嵌套在函数outer内部 函数outer返回函数inner，并将值赋给了f1 123456789101112131415161718192021// 实现累加：方式1var a = 0;var add = function()&#123; a++; console.log(a)&#125;add();add();//方式2 ：闭包var add = (function()&#123; var a = 0; return function()&#123; a++; console.log(a); &#125;&#125;)();console.log(a); //undefinedadd();add();//方式2的优点：减少全局变量，将变量私有化 闭包与变量的关系 闭包只能取得包含函数中任何变量的最后一个值。 1234567891011121314151617181920212223242526272829function f1() &#123; var res = new Array(); for(var i=0;i&lt;10;i++)&#123; res[i] = function() &#123; alert(i); &#125;; &#125; return res;&#125;var f2 = f1();var f2 = f1();f2[0]();//alert 10//并不会返回一次弹出0-9的函数数组，而是弹出10个10的函数数组,因为res中每个函数的作用域中都保存着f1()的活动对象，引用的是同一个变量i，当f1()返回后i的值为10解决方法：function f1() &#123; var res = new Array(); for(var i=0;i&lt;10;i++)&#123; res[i] = (function(num) &#123; return function ()&#123; alert(num); &#125; &#125;)(i);//函数参数按值传递 &#125; return res;&#125;var f2 = f1();var f2 = f1();f2[0]();//alert 0 内存泄露及解决方案 垃圾回收机制说到内存管理，自然离不开JS中的垃圾回收机制，有两种策略来实现垃圾回收：标记清除 和 引用计数； 标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。 2008年为止，IE，Firefox，opera，chrome，Safari的javascript都用使用了该方式； 引用计数：跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个值的引用次数就是1，如果这个值再被赋值给另一个变量，则引用次数加1。相反，如果一个变量脱离了该值的引用，则该值引用次数减1，当次数为0时，就会等待垃圾收集器的回收。 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。早期的IE版本里（ie4-ie6）采用是计数的垃圾回收机制，闭包导致内存泄露的一个原因就是这个算法的一个缺陷。 123456window.onload = function()&#123; var ele = document.getElementById(&quot;id&quot;); ele.onclick = function()&#123; alert(ele.id); &#125;&#125; 这段代码为什么会造成内存泄露？ 123ele.onclick = function()&#123; alert(ele.id); &#125; 执行这段代码的时候，将匿名函数对象赋值给ele的onclick属性；然后匿名函数内部又引用了ele对象，存在循环引用，所以不能被回收。 解决方法： 12345678window.onload = function()&#123; var ele = document.getElementById(&quot;id&quot;); var id = ele.id; //解除循环引用 ele.onclick = function()&#123; alert(id); &#125; ele = null; // 将闭包引用的外部函数中活动对象清除&#125; 总结闭包的优缺点 优点： 当需要一个变量常驻内存时，闭包可以实现一个变量常驻内存 (如果多了就占用内存了) 避免全局变量的污染 私有化变量 实现封装性 缺点: 因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存 常驻内存，增大内存的开销，使用不当就会造成内存泄漏。 闭包的一些应用 计数器 1234567891011121314151617181920212223242526 function makeCounter() &#123; var count = 0; return &#123; update: function() &#123; count++; &#125;, get: function() &#123; return count; &#125; &#125;;&#125;var personCounter = makeCounter();// var count = 0;function Person() &#123; // count++; personCounter.update();&#125;new Person;new Person;new Person;new Person;new Person;new Person;new Person;// console.log(count);console.log(personCounter.get()); // 7 沙箱模式–匿名自调用函数。很多的框架都使用了沙箱模式与外界隔离。即可以分割作用域,内部代码自执行。在实际开发中，可以考虑将全局对象当做实参传入沙箱内部的变量，以提高js性能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //沙箱:模块化,沙箱是一个隔离的环境,最大的好处就是避免全局变量的污染.var model = (function () &#123;//一个匿名的立即执行函数 var price = 900;//这是一个model局部的变量,外界无法访问,无法修改 //有效的保障了属性的安全性 return &#123; pay: function (money) &#123; if (money &lt; price) &#123; console.log("您的消费不够,请继继续消费"); &#125; else &#123; console.log("恭喜成为VIP"); &#125; &#125; &#125;&#125;)();console.log(model.pay(800));//"消费不够.." undefined model.pay(1000);//"VIP..."//千万注意不用打印,pay函数本身就有输出,如果在console.log中//会输出函数的返回值.//在面向对象中使用沙箱//应用场景:在页面初始化的时候要用到f1,f2,f3三个函数//这三个函数不想让外界访问,需要把这单个方法声明成为构造函数//内部私有的变量var songManger = (function()&#123; function f1()&#123; console.log("函数f1的方法"); &#125; function f2()&#123; console.log("函数f2的方法"); &#125; function f3()&#123; console.log("函数f4的方法"); &#125; function SongManger()&#123;//声明一个构造函数 &#125; SongManger.prototype=&#123;//在原型对象上扩展方法 init:function()&#123; f1(); f2(); f3(); &#125; &#125;; // return SongManger;//注意这个返回的是构造函数,使用之前需要先实例化一下 return new SongManger;//把构造函数返回,实例化一下,这样外边就不需要实例化了&#125;)();songManger.init();// 缓存 – (例子:优化fib递归调用性能) 12345678910111213141516171819202122232425262728// 解决方案: 将每一次计算的结果，缓存起来。// 1. 在求值时，首先在缓存里拿。// 2. 如果有值，就直接返回。// 3. 如果没有值，就重新计算。将结算结果缓存并返回。 // 1. 确定缓存的数据结构 []// 2. // 获取求fib数列第n项值的闭包函数var fib = function () &#123; // 缓存计算结果 var cache = []; // 返回求fib数列的闭包函数 return function( n ) &#123; // 从缓存获取数据 var val = cache[n]; // 如果有值, 直接返回值 if(val) return val; // 如果没有值 else &#123; // 如果n的值 为1 或者 2,值为 1. if(n === 1 || n === 2) val = 1; // 如果n的值 大于 2, 递归重新求值 else if(n &gt; 2) val = arguments.callee(n - 1) + arguments.callee(n - 2); // 将重新计算的值,缓存起来并返回 return cache[n] = val; &#125; &#125;;&#125;(); 实现面向对象的封装 1234567891011121314151617181920 function Person(name, age) &#123; return &#123; getAge: function() &#123; return age; &#125;, getName: function() &#123; return name &#125;, setAge: function(val) &#123; age = val; &#125; &#125;;&#125;var zs = new Person('张三', 18);console.log(zs.name); // undefinedconsole.log(zs.getName());console.log(zs.age);// undefinedconsole.log(zs.getAge());zs.setAge(68);console.log(zs.getAge()); 科里化/参数复用：将一个拥有多个参数的函数 转化成 一个单一参数函数的形式。 1234567891011121314151617181920212223242526272829//科里化的本质可以理解为把一个函数作为另一个函数的参数//而且被作为参数的函数,多为闭包结构,因为需要返回一个参数作为新的参数//如果为闭包结构,那么在外层函数传入此函数作为参数的时候,多半在调用参数的时候需要再传入参数window.onload=function()&#123; function selectLi(fn)&#123; //获取所有指定元素 var lis=document.querySelectorAll("#nav li"); //遍历获取的li元素,添加点击事件 for(var i=0;i&lt;lis.length;i++)&#123; lis[i].addEventListener("click",function()&#123; switch (this.getAttribute("data-name"))&#123; case "find" : fn("这是发现音乐");break; case "mine" : fn("这是我的音乐");break; case "friend" : fn("这是我的朋友");break; &#125; &#125;) &#125; &#125; //获取指定元素修改其中的文本 function changeText()&#123; var content=document.querySelector("#content"); return function(text)&#123; content.innerHTML=text; &#125; &#125; //将一个函数传入另一个函数作为参数,可以认为是科里化最大的特征 //如果有类似的需求,以后可以直接将函数传入,更改其中传入的参数即可,以达到参数复用的地步 selectLi(changeText());&#125; 延迟计算/执行就是通过闭包,先保存数据,最后根据需求再进行计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 // 需求:统计某公司销售人员周售楼总数(周平均) /*var weelySales = 0; function dailySales(val) &#123; weelySales += val; &#125; dailySales(1); dailySales(2); dailySales(3); dailySales(4); dailySales(5); dailySales(6); dailySales(7); console.log(weelySales); // 28*//** * [curryingSales 创建可以获取和保存数据闭包函数] * @param &#123;Function&#125; fn [fn函数决定是获取周总数（平均数）] * @return &#123;[type]&#125; [闭包函数] */ function curryingSales(fn) &#123; var dailySales = []; return function(val) &#123; // 根据fn，获取售楼数。 if(val == undefined)&#123; //假如不传参数,代表获取,具体获取什么参数由fn决定 //这时只需要将dailySales作为参数传入fn即可 //这里必须要有return,否则curryingSales无法得到返回值,因为在这里需求是获取数据,如果没有返回值就无法获取数据 return fn.apply(null, dailySales); &#125; else &#123; //假如传参数,代表保存数据 dailySales.push(val); &#125; &#125;; &#125; //这里的需求是获取一周的数据总和//这里的函数可以随时根据需求修改自己的逻辑var weeklyTotal = curryingSales(function() &#123; var sum = 0; for(var i = 0,l = arguments.length; i &lt; l;i++)&#123; sum += arguments[i]; &#125; return sum;&#125;);//保存数据weeklyTotal(1);weeklyTotal(2);weeklyTotal(3);weeklyTotal(4);weeklyTotal(5);weeklyTotal(6);weeklyTotal(7);//获取周数据的总和console.log(weeklyTotal()); 提前返回提前返回就是在对需要重复处理的需求时(例如兼容性处理),先对处理结果进行判断返回,从而避免每次调用的时候都进行判断 12345678910111213141516171819202122232425262728293031323334353637 //需求:兼容IE和普通浏览器的事件添加 // IE:// attachEvent(type, callback)// W3C:// addEventListener(type, callback, useCapture)/** * [addEvent 兼容事件绑定] * @param &#123;[type]&#125; elem [绑定事件的dom元素] * @param &#123;[type]&#125; type [事件的类型] * @param &#123;Function&#125; callback [事件处理程序] * @param &#123;[type]&#125; captrue [是否使用捕获阶段] */// =============缺点：每一次执行addEvent方法都要检测浏览器能力=======================/*var addEvent = function(elem, type, callback, captrue) &#123; // 浏览器支持addEventListener方法 if(window.addEventListener)&#123; elem.addEventListener(type, callback, captrue); &#125; else &#123; // 浏览器支持attachEvent方法 elem.attachEvent('on' + type, callback); &#125; &#125;;*/// ==================科里化提前返回==================var addEvent = function() &#123; // 浏览器支持addEventListener方法 if(window.addEventListener)&#123; return function(elem, type, callback, captrue) &#123; elem.addEventListener(type, callback, captrue); &#125;; &#125; else &#123; // 浏览器支持attachEvent方法 return function(elem, type, callback) &#123; elem.attachEvent('on' + type, callback); &#125;; &#125;&#125;();//通过提前返回,避免了每次调用函数的的时候都会进行兼容性判断 面试题 123456789101112131415161718 var foo = ( function() &#123; var secret = 'secret'; // “闭包”内的函数可以访问 secret 变量，而 secret 变量对于外部却是隐藏的 return &#123; get_secret: function () &#123; // 通过定义的接口来访问 secret return secret; &#125;, new_secret: function ( new_secret ) &#123; // 通过定义的接口来修改 secret secret = new_secret; &#125; &#125;;&#125; () );foo.get_secret (); // 得到 'secret'foo.secret; // Type error，访问不能foo.new_secret ('a new secret'); // 通过函数接口，我们访问并修改了 secret 变量foo.get_secret (); // 得到 'a new secret' 123456789101112131415161718192021222324252627282930313233343536373839var name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); // the windowvar name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); // My Objectvar age=100; function test() &#123; this.age=50; return function () &#123; return this.age; &#125; &#125; var m=new test(); // console.log(m.age); // 50 console.log(m()); // 100var n=test(); console.log(n()); // 50 12345678910function getRandom()&#123; var random=Math.random(); return function()&#123; return random; &#125;; &#125; var result=getRandom(); for (var i = 0; i &lt; 10; i++) &#123; console.log(result()); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie和session以及node相关的中间件使用]]></title>
      <url>%2F2016%2F12%2F29%2Fcookie%E5%92%8Csession%E4%BB%A5%E5%8F%8Anode%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[原生属性概念 HTTP协议与状态保持：Http是一个无状态协议 实现状态保持的方案： 修改Http协议，使得它支持状态保持(难做到) Cookies：通过客户端来保持状态信息 Cookie是服务器发给客户端的特殊信息 cookie是以文本的方式保存在客户端，每次请求时都带上它 Session：通过服务器端来保持状态信息 Session是服务器和客户端之间的一系列的交互动作 服务器为每个客户端开辟内存空间，从而保持状态信息.由于需要客户端也要持有一个标识(id)，因此，也要求服务器端和客户端传输该标识,标识(id)可以借助Cookie机制或者其他的途径来保存 COOKIE机制 Cookie的基本特点 Cookie保存在客户端 只能保存字符串对象，不能保存对象类型 需要客户端浏览器的支持：客户端可以不支持，浏览器用户可能会禁用Cookie 采用Cookie需要解决的问题 Cookie的创建 通常是在服务器端创建的(当然也可以通过javascript来创建) 服务器通过在http的响应头加上特殊的指示，那么浏览器在读取这个指示后就会生成相应的cookie了 Cookie存放的内容 业务信息(“key”,”value”) 过期时间 域和路径 浏览器是如何通过Cookie和服务器通信 通过请求与响应，cookie在服务器和客户端之间传递 每次请求和响应都把cookie信息加载到响应头中；依靠cookie的key传递。 cookie的创建 express直接提供了api,只需要在需要使用的地方调用如下api即可 12345function(req, res, next)&#123; ... res.cookie(name, value [, options]); ...&#125; express就会将其填入Response Header中的Set-Cookie，达到在浏览器中设置cookie的作用。 name: 类型为String value: 类型为String和Object，如果是Object会在cookie.serialize()之前自动调用JSON.stringify对其进行处理 Option: 类型为对象，可使用的属性如下 domain：cookie在什么域名下有效，类型为String,。默认为网站域名 expires: cookie过期时间，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。 httpOnly: 只能被webserver访问，类型Boolean。 maxAge: 实现expires的功能，设置cookie过期的时间，类型为String，指明从现在开始，多少毫秒以后，cookie到期。 path: cookie在什么路径下有效，默认为’/‘，类型为String,匹配该路径才发送这个 cookie。 secure：只能被HTTPS使用，类型Boolean，默认为false signed:使用签名，类型Boolean，默认为false。express会使用req.secret来完成签名，需要cookie-parser配合使用` 1234567891011res.cookie('name', 'koby', &#123; domain: '.example.com', path: '/admin', secure: true &#125;);//cookie的有效期为900000msres.cookie('rememberme', '1', &#123; expires: new Date(Date.now() + 900000), httpOnly: true &#125;);//cookie的有效期为900000msres.cookie('rememberme', '1', &#123; maxAge: 900000, httpOnly: true &#125;);//cookie的value为对象 res.cookie('cart', &#123; items: [1,2,3] &#125;);res.cookie('cart', &#123; items: [1,2,3] &#125;, &#123; maxAge: 900000 &#125;);res.cookie('name', 'tobi', &#123; signed: true &#125;); cookie的删除 express直接提供了api删除浏览器中的cookie,只需要在需要使用的地方调用如下api即可 12345function(req, res, next)&#123; ... res.clearCookie(name [, options]); ...&#125; session cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。 session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 connect.sid 这个字段，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。 这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid 字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。 session 可以存放在 内存、 cookie本身 redis 或 memcached 等缓存中 数据库线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题. 工作流程:当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)。 客户的信息都保存在session中。 创建session可以概括为三个步骤： 生成全局唯一标识符（sessionid）； 开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享； 将session的全局唯一标示符发送给客户端。问题的关键就在服务端如何发送这个session的唯一标识上。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：cookie和URL重写。 cookie-parser 利用cookie-parser读取cookie npm安装命令 1$npm install cookie-parser --save 使用方式 123456789var express = require(&apos;express&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var app = express();//不使用签名app.use(cookiePareser());//若需要使用签名，需要指定一个secret,字符串,否者会报错app.use(cookiePareser(&apos;Simon&apos;)); 如果没有为signed功能，cookie-parser通过如下代码解析req.headers.cookie 1234567891011121314151617181920212223242526272829303132333435363738394041 //index.js var cookie = require(&apos;cookie&apos;); var parse = require(&apos;./lib/parse&apos;); if (req.cookies) return next(); //如果存在req.cookies跳过这个middleware var cookies = req.headers.cookie; //保存对象地址，提高运行效率 req.cookies = Object.create(null); //创建一个对象，解析后的且未使用签名的cookie保存在req.cookies中 req.cookies = cookie.parse(cookies); //与express中调用cookie.serialize()对应，解析cookie req.cookies = JSONCookies(req.cookies); // JSON字符序列转化为JSON对象 //./lib/parse.js //接续cookie中的JSON字符序列 exports.JSONCookies = function(obj)&#123; var cookies = Object.keys(obj); //获取obj对象的property var key; var val; //循环判断并解析 for (var i = 0; i &lt; cookies.length; i++) &#123; key = cookies[i]; val = exports.JSONCookie(obj[key]); //如果是JSON字符序列则保存 if (val) &#123; obj[key] = val; &#125; &#125; return obj; &#125;; //解析JSON字符序列 exports.JSONCookie = function(str) &#123; if (!str || str.substr(0, 2) !== &apos;j:&apos;) return; //判断是否为JSON字符序列，如果不是返回undefined try &#123; return JSON.parse(str.slice(2)); //解析JSON字符序列 &#125; catch (err) &#123; // no op &#125; &#125;; 如果使用了signed功能，cookie-parser通过如下代码解析req.headers.cookie 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//index.jsvar cookie = require(&apos;cookie&apos;);var parse = require(&apos;./lib/parse&apos;);if (req.cookies) return next(); //如果存在req.cookies跳过这个middleware//调用res.cookie(name, value , &#123;singed: true&#125;)，express会使用req.secret。故使用了签名功能，需给cookie-parser传递secret，且res.cookie(name, value , &#123;singed: true&#125;)需在cookie-parser插 //入express后再使用req.secret = secret; req.cookies = Object.create(null);req.signedCookies = Object.create(null); //创建req.singedCookies，所有解析后的signed cookie都保存在这个对象中，req.cookies中没有任何signed cookie// 如果请求中没有cookiesif (!cookies) &#123; return next();&#125;req.cookies = cookie.parse(cookies, options); //与express中调用cookie.serialize()对应，解析cookie// parse signed cookiesif (secret) &#123; //判断是否为singed cookie。如果是，则去掉签名，同时删除req.cookies中对应的property，将这些去掉签名的cookie组成一个对象，保存在req.signedCookies中 req.signedCookies = parse.signedCookies(req.cookies, secret); // JSON字符序列转化为JSON对象 req.signedCookies = parse.JSONCookies(req.signedCookies); &#125;//./lib/parse.jsvar signature = require(&apos;cookie-signature&apos;);exports.signedCookies = function(obj, secret)&#123; var cookies = Object.keys(obj); //获取obj对象的property var dec; var key; var ret = Object.create(null); //创建返回对象 var val; for (var i = 0; i &lt; cookies.length; i++) &#123; key = cookies[i]; val = obj[key]; dec = exports.signedCookie(val, secret); //判断是否是去掉签名后的value，如果是保存该值到ret中同时删除obj中的相应property if (val !== dec) &#123; ret[key] = dec; delete obj[key]; &#125; &#125; return ret;&#125;;exports.signedCookie = function(str, secret)&#123; //判断是否添加了签名，如果添加了签名则去掉签名，否则返回原字符串 return str.substr(0, 2) === &apos;s:&apos; ? signature.unsign(str.slice(2), secret) : str;&#125;; 综上所诉，解析后的unsigned cookie保存在req.cookies中，而解析后的signed cookie只保存在req.signedCookies中。使用cookie-parser插件，后续代码直接使用req.cookies或者req.signedCookies即可 cookie-parser简单实用 实例: 1234567891011121314151617181920212223var express = require(&apos;express&apos;);// 首先引入 cookie-parser 这个模块var cookieParser = require(&apos;cookie-parser&apos;);var app = express();app.listen(3000);// 使用 cookieParser 中间件，cookieParser(secret, options)// 其中 secret 用来加密 cookie 字符串（下面会提到 signedCookies）// options 传入上面介绍的 cookie 可选参数app.use(cookieParser());app.get(&apos;/&apos;, function (req, res) &#123;// 如果请求中的 cookie 存在 isVisit, 则输出 cookie// 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟if (req.cookies.isVisit) &#123; console.log(req.cookies); res.send(&quot;再次欢迎访问&quot;); &#125; else &#123; res.cookie(&apos;isVisit&apos;, 1, &#123;maxAge: 60 * 1000&#125;); res.send(&quot;欢迎第一次访问&quot;); &#125;&#125;); express-session 方法就是 session(options)，其中 options 中包含可选参数，主要有： name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid 。可以认为,这个就是cookie的name store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。 secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。 cookie: 设置存放 session id 的 cookie 的相关选项，默认为 1(default: &#123; path: &apos;/&apos;, httpOnly: true, secure: false, maxAge: null &#125;) genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 uid2 这个 npm 包。 rolling: 每个请求都重新设置一个 cookie，默认为 false。 resave: 即使 session 没有被修改，也保存 session 值，默认为 true。 只需要用express app的use方法将session挂载在‘/’路径即可，这样所有的路由都可以访问到session。可以给要挂载的session传递不同的option参数，来控制session的不同特性. 一旦我们将express-session中间件用use挂载后，我们可以很方便的通过req参数来存储和访问session对象的数据。req.session是一个JSON格式的JavaScript对象，我们可以在使用的过程中随意的增加成员，这些成员会自动的被保存到option参数指定的地方，默认即为内存中去。 示例: 12345678910111213141516171819202122232425var express = require(&apos;express&apos;);// 首先引入 express-session 这个模块var session = require(&apos;express-session&apos;);var app = express();app.listen(5000);// 按照上面的解释，设置 session 的可选参数app.use(session(&#123; secret: &apos;recommand 128 bytes random string&apos;, // 建议使用 128个字符的随机字符串 cookie: &#123; maxAge: 60 * 1000 &#125;&#125;));app.get(&apos;/&apos;, function (req, res) &#123; // 检查 session 中的 isVisit 字段 // 如果存在则增加一次，否则为 session 设置 isVisit 字段，并初始化为 1。if(req.session.isVisit) &#123; req.session.isVisit++; res.send(&apos;&lt;p&gt;第 &apos; + req.session.isVisit + &apos;次来此页面&lt;/p&gt;&apos;);&#125; else &#123; req.session.isVisit = 1; res.send(&quot;欢迎第一次来这里&quot;); console.log(req.session); &#125;&#125;); 个人体会:整体流程应该是这样子的: 首先,服务器端创建了cookie,并要传给浏览器,这样浏览器下次再来访问的时候,带上cookie存储的相关信息,就可以达到保存状态的目的 但是需要给请求也就是req挂上相应的信息才行.用了中间件cookie.parser之后,插件自动帮你挂上了这个请求信息,通过处理将信息转化为了一个json对象,不用自己手动添加了 但是考虑到cookie的诸多安全性问题,需要用session将具体的状态信息保存在服务器端,此时用express-session插件,会给每个不同的访问创建一个key-val的json信息对,key返回给浏览器,而最关键的val保存在服务器,浏览器每次访问的时候,req都会带着key去访问,服务器凭借key去找val,服务器将val返回给浏览器.这样就一定程度上保证了安全性 如有错误,敬请指正]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组基本概念和原生方法]]></title>
      <url>%2F2016%2F12%2F26%2F%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[数组基本操作创建一个数组123var fruits = ["Apple", "Banana"];console.log(fruits.length);// 2 通过索引访问数组元素12345var first = fruits[0];// Applevar last = fruits[fruits.length - 1];// Banana 遍历一个数组12345fruits.forEach(function (item, index, array) &#123; console.log(item, index);&#125;);// Apple 0// Banana 1 属性 Array.prototype.constructor所有的数组实例都继承了这个属性，它的值就是 Array，表明了所有的数组都是由 Array 构造出来的。 Array.prototype.length上面说了，因为 Array.prototype 也是个数组，所有它也有 length 属性，这个值为 0，因为它是个空数组。 原生方法 下面的这些方法会改变调用它们的对象自身的值 Array.prototype.fill()将数组中指定区间的所有元素的值，都替换成某个固定的值。 语法:arr.fill(value[, start = 0[, end = this.length]]) 参数 value用来填充数组元素的值。 start可选，开始索引。 end可选，结束索引。 实例12345678[1, 2, 3].fill(4) // [4, 4, 4][1, 2, 3].fill(4, 1) // [1, 4, 4][1, 2, 3].fill(4, 1, 2) // [1, 4, 3][1, 2, 3].fill(4, 1, 1) // [1, 2, 3][1, 2, 3].fill(4, -3, -2) // [4, 2, 3][1, 2, 3].fill(4, NaN, NaN) // [1, 2, 3]Array(3).fill(4); // [4, 4, 4][].fill.call(&#123;length: 3&#125;, 4) // &#123;0: 4, 1: 4, 2: 4, length: 3&#125; Array.prototype.pop()删除数组的最后一个元素，并返回这个元素。 语法:array.pop() 描述 pop方法删除一个数组中的最后一个元素，并且把这个删除掉的元素返回给调用者。pop 被有意设计成具有通用性，该方法可以通过 call 或 apply 方法应用于一个类数组（array-like）对象上。 实例:下面的代码首先创建了一个拥有四个元素的数组 myFish，然后删除掉它的最后一个元素。 12345var myFish = ["angel", "clown", "mandarin", "surgeon"];console.log("myFish before: " + myFish);var popped = myFish.pop();console.log("myFish after: " + myFish);console.log("Removed this element: " + popped); Array.prototype.push()在数组的末尾增加一个或多个元素，并返回数组的新长度。 语法:arr.push(element1, …, elementN) 参数:elementN被添加到数组末尾的元素。 返回值当调用该方法时，新的 length 属性值将被返回。 实例 123456//添加元素到数组.下面的代码创建了 sports 数组，包含两个元素，然后又把两个元素添加给它。total 变量为数组的新长度值。var sports = ["soccer", "baseball"];var total = sports.push("football", "swimming");console.log(sports); // ["soccer", "baseball", "football", "swimming"]console.log(total); // 4 123456789//合并两个数组该示例使用 apply() 添加第二个数组的所有元素。var vegetables = ['parsnip', 'potato'];var moreVegs = ['celery', 'beetroot'];// Merge the second array into the first one// Equivalent to vegetables.push('celery', 'beetroot');Array.prototype.push.apply(vegetables, moreVegs);console.log(vegetables); // ['parsnip', 'potato', 'celery', 'beetroot'] Array.prototype.reverse()颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。 语法:arr.reverse() 描述:reverse 方法颠倒数组中元素的位置，并返回该数组的引用。 示例:12345//下例将会创建一个数组 myArray，其包含三个元素，然后颠倒该数组。var myArray = ['one', 'two', 'three'];myArray.reverse(); console.log(myArray) // ['three', 'two', 'one'] Array.prototype.shift()删除数组的第一个元素，并返回这个元素。 语法:arr.shift() 描述: shift 方法移除索引为 0 的元素(即第一个元素)，并返回被移除的元素，其他元素的索引值随之减 1。如果 length 属性的值为 0 (长度为 0)，则返回 undefined。shift 方法并不局限于数组：该方法亦可通过 call 或 apply 作用于对象上。对于不包含 length 属性的对象，将添加一个值为 0 的 length 属性。 实例1234567891011121314//移除数组中的一个元素.以下代码展示了 myFish 数组调用 shift 方法：var myFish = ['angel', 'clown', 'mandarin', 'surgeon'];console.log('调用 shift 之前: ' + myFish);// "调用 shift 之前: angel,clown,mandarin,surgeon"var shifted = myFish.shift(); console.log('调用 shift 之后: ' + myFish); // "调用 shift 之后: clown,mandarin,surgeon" console.log('被删除的元素: ' + shifted); // "被删除的元素: angel" Array.prototype.sort()对数组元素进行排序，并返回当前数组。 语法:arr.sort([compareFunction]) 参数:compareFunction可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的诸个字符的Unicode位点进行排序。 描述:如果没有指明 compareFunction，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。数字比大小时，9 出现在 80 之前，但这里比较时数字会先被转换为字符串，所以 “80” 比 “9” 要靠前。123456789101112var fruit = ['cherries', 'apples', 'bananas'];fruit.sort(); // ['apples', 'bananas', 'cherries']var scores = [1, 10, 2, 21]; scores.sort(); // [1, 10, 2, 21]// Watch out that 10 comes before 2,// because '10' comes before '2' in Unicode code point order.var things = ['word', 'Word', '1 Word', '2 Words'];things.sort(); // ['1 Word', '2 Words', 'Word', 'word']// In Unicode, numbers come before upper case letters,// which come before lower case letters. 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。记 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ，a和b的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003年之前的版本）； 如果 compareFunction(a, b) 大于 0 ，b会被排列到a之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 Array.prototype.splice()在任意的位置给数组添加或删除任意个元素。 Array.prototype.unshift()在数组的开头增加一个或多个元素，并返回数组的新长度。 下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 Array.prototype.concat()返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。 语法:var new_array = old_array.concat(value1[, value2[, …[, valueN]]]) 参数:valueN 需要与原数组合并的数组或非数组值。 返回值:新的Array实例 描述: concat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组. concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里. 实例: 123456//下面的代码演示两个数组合并为一个新数组:var alpha = ["a", "b", "c"];var numeric = [1, 2, 3];// 组成新数组 ["a", "b", "c", 1, 2, 3]; 原数组 alpha 和 numeric 未被修改var alphaNumeric = alpha.concat(numeric); 1234567//下面的代码演示三个数组合并为一个新数组:var num1 = [1, 2, 3];var num2 = [4, 5, 6];var num3 = [7, 8, 9];// 组成新数组[1, 2, 3, 4, 5, 6, 7, 8, 9]; 原数组 num1, num2, num3 未被修改var nums = num1.concat(num2, num3); 12345//下面的代码演示将多个数组和多个非数组值合并为一个新数组:var alpha = ['a', 'b', 'c'];// 组成新数组 ["a", "b", "c", 1, 2, 3], 原alpha数组未被修改var alphaNumeric = alpha.concat(1, [2, 3]); Array.prototype.includes()判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。 语法:var boolean = array.includes(searchElement[, fromIndex]) 参数: searchElement需要查找的元素值。 fromIndex可选参数。从该索引处开始查找 searchElement，默认为 0。 返回值一个boolean 示例12345[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true Array.prototype.join()连接所有数组元素组成一个字符串。 语法: str = arr.join([separator = ‘,’]) 参数: separator可选，用于指定连接每个数组元素的分隔符。分隔符会被转成字符串类型；如果省略的话，默认为一个逗号。如果 seprator 是一个空字符串，那么数组中的所有元素将被直接连接。 描述:所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。 实例:例子: 使用四种不同的分隔符连接数组元素下例首先创建了一个数组 a，包含有三个元素，然后用四种不同的分隔符连接所有数组元素。首先是默认的分隔符逗号，然后是一个逗号加空格，接下来是一个加号前后加空格，最后是一个空字符串。12345var a = ['Wind', 'Rain', 'Fire'];var myVar1 = a.join(); // myVar1的值变为"Wind,Rain,Fire"var myVar2 = a.join(', '); // myVar2的值变为"Wind, Rain, Fire"var myVar3 = a.join(' + '); // myVar3的值变为"Wind + Rain + Fire"var myVar4 = a.join(''); // myVar4的值变为"WindRainFire" Array.prototype.slice()抽取当前数组中的一段元素组合成一个新数组。 语法:arr.slice([begin[,end]]) 参数: begin从该索引处开始提取原数组中的元素（从0开始）。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 0 开始。 end在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end的所有元素（包含begin，但不包含end）。 slice(1,4)提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。如果该参数为负数，则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1)表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果 end被省略，则slice会一直提取到原数组末尾。 返回值一个含有提取元素的新数组 描述:slice 不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。如果向两个数组任一中添加了新元素，则另一个不会受到影响。 实例: 1234567//返回数组中的一部分// Our good friend the citrus from fruits examplevar fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];var citrus = fruits.slice(1, 3);// puts --&gt; ["Orange","Lemon"] 12345678910111213141516171819202122232425262728//使用 slice.在下例中, slice从myCar中创建了一个新数组newCar.两个数组都包含了一个myHonda对象的引用. 当myHonda的color属性改变为purple, 则两个数组中的对应元素都会随之改变/ 使用slice方法从myCar中创建一个newCar.var myHonda = &#123; color: "red", wheels: 4, engine: &#123; cylinders: 4, size: 2.2 &#125; &#125;;var myCar = [myHonda, 2, "cherry condition", "purchased 1997"];var newCar = myCar.slice(0, 2);// 输出myCar, newCar,以及各自的myHonda对象引用的color属性.print("myCar = " + myCar.toSource());print("newCar = " + newCar.toSource());print("myCar[0].color = " + myCar[0].color);print("newCar[0].color = " + newCar[0].color);// 改变myHonda对象的color属性.myHonda.color = "purple";print("The new color of my Honda is " + myHonda.color);//输出myCar, newCar中各自的myHonda对象引用的color属性.print("myCar[0].color = " + myCar[0].color);print("newCar[0].color = " + newCar[0].color);//上述代码输出myCar = [&#123;color:"red", wheels:4, engine:&#123;cylinders:4, size:2.2&#125;&#125;, 2, "cherry condition", "purchased 1997"]newCar = [&#123;color:"red", wheels:4, engine:&#123;cylinders:4, size:2.2&#125;&#125;, 2]myCar[0].color = red newCar[0].color = redThe new color of my Honda is purplemyCar[0].color = purplenewCar[0].color = purple 123456789101112131415161718//类数组（Array-like）对象EDITslice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个数组。你只需将该方法绑定到这个对象上。下述代码中 list 函数中的 arguments 就是一个类数组对象。function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3]除了使用 Array.prototype.slice.call(arguments)，你也可以简单的使用 [].slice.call(arguments) 来代替。另外，你可以使用 bind 来简化该过程。var unboundSlice = Array.prototype.slice;var slice = Function.prototype.call.bind(unboundSlice);function list() &#123; return slice(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3] Array.prototype.toString()返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。 语法:arr.tostring() 对于数组对象，toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。例如，下面的代码创建了一个数组，然后使用 toString 方法把该数组转成一个字符串。 12var monthNames = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;];var myVar = monthNames.toString(); // assigns &quot;Jan,Feb,Mar,Apr&quot; to myVar. 注意:当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 toString 方法。 Array.prototype.indexOf()返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 语法:arr.indexOf(searchElement[, fromIndex = 0]) 参数: searchElement 要查找的元素 fromIndex 开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。 如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0. 实例: 以下例子使用indexOf方法确定多个值在数组中的位置。 123456var array = [2, 5, 9];array.indexOf(2); // 0array.indexOf(7); // -1array.indexOf(9, 2); // 2array.indexOf(2, -1); // -1array.indexOf(2, -3); // 0 找出指定元素出现的所有位置 12345678910var indices = [];var array = ['a', 'b', 'a', 'c', 'a', 'd'];var element = 'a';var idx = array.indexOf(element);while (idx != -1) &#123; indices.push(idx); idx = array.indexOf(element, idx + 1);&#125;console.log(indices);// [0, 2, 4] Array.prototype.lastIndexOf()返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 语法:arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1]) 参数: searchElement被查找的元素。 fromIndex从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 实例: 下例使用 lastIndexOf 定位数组中的值。 12345678910111213var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3index = array.lastIndexOf(7);// index is -1index = array.lastIndexOf(2, 3);// index is 3index = array.lastIndexOf(2, 2);// index is 0index = array.lastIndexOf(2, -2);// index is 0index = array.lastIndexOf(2, -1);// index is 3 例子：查找所有元素 下例使用 lastIndexOf查找到一个元素在数组中所有的索引（下标），并使用 push 将所有添加到另一个数组中。 12345678910var indices = [];var array = ['a', 'b', 'a', 'c', 'a', 'd'];var element = 'a';var idx = array.lastIndexOf(element);while (idx != -1) &#123; indices.push(idx); idx = (idx &gt; 0 ? array.lastIndexOf(element, idx - 1) : -1);&#125;console.log(indices);// [4, 2, 0]; 在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在回调函数执行之前，数组的长度会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。 Array.prototype.forEach()为数组中的每个元素执行一次回调函数。 语法array.forEach(callback[, thisArg]) 参数 callback 函数为每个元素执行，接收三个参数： currentValue(当前值) 数组中正在处理的当前元素。 index(索引) 数组中正在处理的当前元素的索引。 array 正在应用forEach()数组。。 thisArg可选 可选参数。当执行回调 函数时用作this的值(参考对象)。 描述: forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括那些值为 undefined 的项）。 callback 函数会被依次传入三个参数： 数组当前项的值 数组当前项的索引 数组对象本身 如果给forEach传递了thisArg 参数，它将作为 callback 函数的执行上下文，类似执行如下函数callback.call(thisArg, element, index, array)。如果 thisArg 值为 undefined 或 null，函数的 this 值取决于当前执行环境是否为严格模式（严格模式下为 undefined，非严格模式下为全局对象）。 forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。 注意: 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。 实例: 下面的代码会为每一个数组元素输出一行记录：12345678function logArrayElements(element, index, array) &#123; console.log("a[" + index + "] = " + element);&#125;[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 9 Array.prototype.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。 语法 arr.every(callback[, thisArg]) 参数 callback用来测试每个元素的函数。 thisArg执行 callback 时使用的 this 值。 描述 every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。 callback 被调用时传入三个参数：元素值，元素的索引，原数组。 如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。 every 不会改变原数组。 every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。 实例: 检测所有数组元素的大小.下例检测数组中的所有元素是否都大于 10。1234567function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true Array.prototype.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 12345678//逻辑类似于everyfunction isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is true Array.prototype.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 12345678//例子：筛选排除掉所有的小值下例使用 filter 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。function isBigEnough(element) &#123; return element &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] Array.prototype.find()找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。 语法:arr.find(callback[, thisArg]) 参数 callback在数组每一项上执行的函数，接收 3 个参数： element当前遍历到的元素。 index当前遍历到的索引。 array数组本身。 thisArg可选，指定 callback 的 this 参数。 描述:find方法对数组中的每一项元素执行一次callback 函数，直至有一个callback返回true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回undefined。注意callback函数只会在分配了值的数组索引上调用，而不会在已删除或未分配值的索引上调用。 调用callback函数带有3个参数：当前元素的值、当前元素的索引，以及数组本身。 如果提供了thisArg参数，那么它将作为每次callback函数执行时的上下文对象，否则上下文对象为undefined。 find方法不会改变数组。 在第一次调用callback函数时会确定元素的索引范围，因此在find方法开始执行之后添加到数组的新元素将不会被callback函数访问到。如果数组中一个尚未被callback函数访问到的元素的值被callback函数所改变，那么当callback函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素不会被访问到。 实例12345678910111213//寻找数组中的质数//下面的例子展示了如何从一个数组中寻找质数（如果找不到质数则返回undefined）function isPrime(element, index, array) &#123; var start = 2; while (start &lt;= Math.sqrt(element)) &#123; if (element % start++ &lt; 1) &#123; return false; &#125; &#125; return element &gt; 1;&#125;console.log([4, 6, 8, 12].find(isPrime)); // undefined, not foundconsole.log([4, 5, 8, 12].find(isPrime)); // 5 Array.prototype.map()返回一个由回调函数的返回值组成的新数组。 语法:array.map(callback[, thisArg]) 参数 callback原数组中的元素经过该方法后返回一个新的元素。 currentValuecallback 的第一个参数，数组中当前被传递的元素。 indexcallback 的第二个参数，数组中当前被传递的元素的索引。 arraycallback 的第三个参数，调用 map 方法的数组。 thisArg 执行 callback 函数时 this 指向的对象。 返回值由回调函数的返回值组成的新数组。 描述 map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。 如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。 map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。 使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。 实例 求数组中每个元素的平方根下面的代码创建了一个新数组，值为原数组中对应数字的平方根。123var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);/* roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] */ 兼容性ES5中新增的数组方法，如下：123456789forEach (js v1.6)map (js v1.6)filter (js v1.6)some (js v1.6)every (js v1.6)indexOf (js v1.6)lastIndexOf (js v1.6)reduce (js v1.8)reduceRight (js v1.8) 以上数组方法有兼容性问题,需要注意]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2016%2F12%2F26%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[简介正则表达式是被用来匹配字符串中的字符组合的模式。在JavaScript中，正则表达式也是对象。这种模式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。 创建正则表达式 使用一个正则表达式字面量1var re = /ab+c/; 正则表达式字面量在脚本加载后编译。若你的正则表达式是常量，使用这种方式可以获得更好的性能。 调用RegExp对象的构造函数1var re = new RegExp("ab+c"); 使用构造函数，提供了对正则表达式运行时的编译。当你知道正则表达式的模式会发生改变， 或者你事先并不了解它的模式或者是从其他地方（比如用户的输入），得到的代码这时比较适合用构造函数的方式。 字符 含义 \ 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前面’\’的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。 反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a/ 代表会匹配 0 个或者多个 a。相反，模式 /a\/ 将 ‘‘ 的特殊性移除，从而可以匹配像 “a“ 这样的字符串。使用 new RegExp(“pattern”) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。 ^ 匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 $ 匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。 * 匹配前一个表达式0次或多次。等价于 {0,}。例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。 + 匹配前面一个表达式1次或者多次。等价于 {1,}。例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。 ? 匹配前面一个表达式0次或者1次。等价于 {0,1}。例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。还可以运用于向前断言，在本表格的 x(?=y) 和 x(?!y) 中有描述。 . （小数点）匹配除了换行符（\n）之外的任何单个字符。例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 x(竖线)y 匹配‘x’或者‘y’。例如，/green(竖线)red/匹配green apple”中的‘green’和“red apple”中的‘red’ {n} n是一个正整数，匹配了前面一个字符刚好发生了n次。比如，/a{2}/不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个’a’。 {n,m} n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中得任意字符，匹配“candy”中得a，匹配“caandy”中得前两个a，也匹配“caaaaaaandy”中得前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。 \b 匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）例子：/\bm/匹配“moon”中得‘m’；/oo\b/并不匹配”moon”中得’oo’，因为’oo’被一个词汇字符’n’紧跟着。/oon\b/匹配”moon”中得’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个词汇字符紧跟着。/\w\b\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着。 \d 匹配一个数字。等价于[0-9]。例如， /\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。 \D 匹配一个非数字字符。等价于[^0-9]。例如， /\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。 \s 匹配一个空白字符，包括空格、制表符、换页符和换行符。例如, /\s\w*/ 匹配”foo bar.”中的’ bar’。 \S 匹配一个非空白字符。例如， /\S\w*/ 匹配”foo bar.”中的’foo’。 \w 匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。例如, /\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。 \W 匹配一个非单字字符。等价于[^A-Za-z0-9]。例如, /\W/ 或者 /[^A-Za-z0-9]/ 匹配 “50%.” 中的 ‘%’。 使用正则表达式使用正则表达式的方法 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。 使用括号的子字符串匹配一个正则表达式模式使用括号，将导致相应的子匹配被记住。例如，/a(b)c /可以匹配字符串“abc”，并且记得“b”。回调这些括号中匹配的子串，使用数组元素[1],……[n]。 使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。下面的例子说明了如何使用括号的子字符串匹配。 下面的脚本使用replace()方法来转换字符串中的单词。在匹配到的替换文本中，脚本使用替代的$ 1,$ 2表示第一个和第二个括号的子字符串匹配。 1234var re = /(\w+)\s(\w+)/;var str = "John Smith";var newstr = str.replace(re, "$2, $1");console.log(newstr); 这个表达式输出 “Smith, John” 通过标志进行高级搜索正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。 123var re = /\w+\s/g;//可以替换成var re = new RegExp("\\w+\\s", "g"); 示范123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384[] 1.表示的是范围, 2.可以把关键性的元字符的本意干掉[0-9] 表示的是一个范围, 0到9所有的数字(包括0包括9)中的一个[3-7] 包括3，也包括7，之间所有的数字中的一个[a-z] 所有的小写字母[A-Z] 所有的大写字母[a-h] a到h之间所有的小写字母,包括a,也包括h 一个请写一个正则表达式 匹配所有的字母中 [a-zA-Z] - 范围表示所有的数字和所有的字母 [0-9a-zA-Z]() 1.提升优先级别 ,2.提取分组:一对括号就是一组( [0-9]([a-z][A-Z]))[0-9]谁是第一组，谁是第二组小括号提取的组,是从左开始算的| 或者的意思 优先级别最低. 除了\n以外的任意的一个单个的字符[] 表示范围可以把正则表达式中特殊含义的元字符的本意干掉[.] 就是一个.[-] 就是一个-. 除了\n以外的任意的一个单个字符[] 范围[0-9][a-z][A-Z][b] b*表示的是前面的这个表达式出现了0次到多次举例子: [0-9][a-z]*+ 表示的是前面的这个表达式出现了 1次到多次举例子: [a-z][0-9]+ &quot;af4&quot;? 表示的是前面的这个表达式出现了 0次到1次举例子: [0-9]? &quot;4545&quot;* + ? 可以看成是元字符中的限定符&#123;0,&#125; 表示的是前面的这个表达式出现了0次到多次 *&#123;0,1&#125; 表示的是前面的这个表达式出现了0次到 1次 ?&#123;1,&#125; 表示的是前面的这个表达式出现了1次到多次&#123;3,9&#125; 表示的是前面的这个表达式出现了3次到9次&#123;,4&#125; 这种写法是错误的举例子[a-z]&#123;4,9&#125; 小写字母最少除了4次特殊的:\d 表示的是任意的一个数字 和[0-9] 一样\D 表示的是非数字中的一个 &quot;f&quot;\s 表示的是空白符号 &quot; &quot;\S 非空白符号 &quot;fdf&quot; \w 非特殊符号 &quot;4&quot;\W 特殊符号 &quot;&amp;&quot;^ 1. 以什么开始 2.取反[^0-9] 取反了 (不是数字) ^[0-9] 以数字开头举例子 ^[0-9][a-z]$ 以什么结束 [0-9]$. 除了\n以外的任意一个单个的字符[]表示的范围,[0-9]单个一个数字,[a-z]单个的一个小写字母| 或者() 提升优先级 和分组* 前面的表达式出现了0次到多次+ 前面的表达式出现了1次到多次? 前面的表达式出现了0次到1次&#123;1,9&#125; 前面的表达式出现了1次到9次\d 一个任意数字\D 非数字\s 空白符号\S 非空白符号\w 非特殊符号\W 特殊符号(可以匹配中文)^ 以什么开头， 取反$ 以什么结束\b 单词的边界 hello are you no sha lei]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git常用指令和流程]]></title>
      <url>%2F2016%2F12%2F24%2Fgit%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支 新建一个分支，开发注册功能 新建一个 register.html 新建一个 register.css 修改 index.html ，增加一个 a 链接，链接到 register.html 基于该分支提交修改 开发完毕，再把该分支合并到 master 中 合并后，将 原来的分支删除 分支存在的意义 单人开发毫无意义 只有多人协作才能体现出分支的价值 什么时候去创建分支、什么时候合并分支 团队之间如何正确的使用 Git 分布式 不需要联网就可以在本地生成历史记录 即便你的服务器宕机了，仓库的历史记录永远不会丢失123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] rmdir 目录名称 注意：只能删除空目录 rm 文件名 可以用来删除指定文件 rm -rf 目录名称 可以用来删除一个非空目录 mkdir 目录名称 cd 目录名称 mkdir 目录名称 &amp;&amp; cd 目录名称 vi 编辑器 它是一个命令行编辑器 vim 是 vi 的一个高级版 两个都是一个东西 Visual Interface 可视化接口 vi 文件名 使用 vi 编辑指定文件 默认会进入命令模式 将光标移动到要编辑的位置，输入字母 i 进入编辑模式 注意：千万不要乱打键盘，因为在 vi 中，默认是命令模式，各个字母都表示不同的命令 编辑完毕之后，可以按 Esc 退出编辑模式，进入命令模式 然后直接输入 :w 回车保存编辑 如何退出：:q 退出 vi 如果修改了，但是不想保存，可以直接 :q! 强制退出 如果想要快捷保存修改，则可以 :wq 保存并退出 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步远程操作假设，项目立项了，要开始开发了，领导选择了使用 Git 作为版本管理工具，会有一个核心人员（有一定版本管理工具使用经验）当作源代码仓库管理员，它去创建一个远程仓库，然后做一些基础设施，例如项目结构初始化（做一些开发约定）。 第一天到公司之后，别人会告诉你它们使用的哪个版本管理工具，然后会告诉你该版本仓库的地址：https://github.com/jtbsk/example.git ，你这个时候拿到这个地址然后去 clone 就可以了。这个 clone 也不是任何人都可以 clone 的，公司内部的项目一般都私有的，有权限认证，如果它把地址给你了，但是你 clone 的时候可能会报错（权限错误），如果是权限错误，可能是管理员没有给你添加权限，那这个时候，你跟管理员说一下，帮你添加一个操作权限，然后你再去 clone。 没有远程仓库，本地有：需求就是把本地的仓库放到远程加入你现在在教室，没有网络，但是你要开发一个项目，从来没有被 Git 管理过，则可以直接通过 git init 的形式在你的项目中使用 Git。 先去远端创建一个仓库 接下来通过 git remote add 给远端地址起个短一点的有意义的别名 远端地址 可以通过 git remote 查看所有的远端地址，默认只能看到别名 可以通过 git remote show 远端地址别名 查看某个具体的远端地址信息 然后通过 git push 远端地址别名 要提交到的分支名称 上面的步骤以后每次 push 都需要制定 remote name 为了方便，你可以在 push 的时候，直接通过 git push --set-upstream 远端地址名 分支 使用了该命令提交之后 以后就可以直接 git push 的方式提交了，因为 –set-upstream 就是用来记住你的那个 remote 的 已有远程仓库，直接通过 clone 来拿就可以了 先在远端创建一个仓库 然后通过 clone 的形式克隆到本地 通过 clone 的形式下载下来的仓库默认会创建一个 remote ，名字叫 origin，这是 Git 的默认行为 通过会自动为 push 和 origin 之间建立一个上下游关系 该关系就意味着 每一次使用 git push 的时候，不需要指定 后面的 origin 了 然后再通过 push-pull 的形式推送和拉取源代码1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 多人协作Collaborators 简单粗暴 直接把协作者添加到仓库的权限列表中 项目页面 -&gt; Settings -&gt; Collaborators -&gt; 添加协作者 协作者会收到一封 email ，然后点进去收到一封邮件，同意成为协作者 然后协作者就拥有了对该仓库的提交等权限了 那这个时候，一定团队成员，有一定风险 所以这个时候会做一些口头约定：Code Review 以及代码合并 你不要去合并，由项目管理者去选择合并 提交之前，最好把你的领导叫过来，我要合往master分支提交代码，它去Code Review 大公司里面，有一个职业就是 Code Reviewer 人工审查 Pull Request 先基于团队项目的git仓库 fork 到你的账户下 组长创建一个仓库 在 master 中初始化一些项目的基本结构 完事儿了，让小组成员去 fork 组长创建的仓库 fork 到自己的账户下 然后通过自己账户下 fork 过来的仓库 clone 到本地 然后基于 master 创建一个特性分支 基于特性分支开发（开发完毕不要自己去合并到 master） 把该分支 push 到 Github 上 然后在 Github 上通过 Pull Request 的形式发起一个合并请求 一般都是将你开发的特性分支合并到对方仓库的 master 分支上 组长会收到一个 Pull Request 合并请求 code review 例如代码不合格，就可以发起 review，可以以社交化的形式进行协作 直到没有问题之后，合并到 master 分支上 这个只是合并到你组长的账户下的仓库的 master 上了 对于你的账户下的 master 还是原来的 这个时候，需要和你 fork 的仓库上的 master 进行一次同步 通过 git remote add 名字 地址 把团队仓库地址添加到你的本地 通过 git pull 名字 分支名称 将指定远端仓库的指定分支拉取到本地 其他12# 生成一个可供发布的压缩包$ git archive Git 其它工具 和 IDE 的结合 图形化工具 和 Git 相关的产品 GItlab 码云 coding 资源推荐 Github入门与实践 git学习资料整理 如何高效利用GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[body-parser 部分API]]></title>
      <url>%2F2016%2F12%2F23%2Fbody-parser%E6%8F%92%E4%BB%B6%20API%2F</url>
      <content type="text"><![CDATA[node安装 1$ npm install body-parser API 1var bodyParser =require(&apos;body-parser&apos;) 可以通过body-parser 对象创建中间件，当接收到客户端请求时所有的中间件都会给req.body 添加属性，请求体为空，则解析为空{} （或者出现错误）。 bodyParser.json(options)中间件只会解析 json ，允许请求提任意Unicode编码支持 gzip 和 deflate 编码。 options一个对象，有以下属性 inflate默认为false，true-&gt;压缩的请求体会被解压，false-&gt;压缩的请求提不被解压。 limit控制请求体最大大小，默认为100kb，当为数字时会转换为bytes，当为字符串时，value值会通过 bytes库 转换为字节大小。 reviver此选项会通过JSON.parse直接传给其第二个参数。 strict默认为true，当为true时只接受数组和对象，当为false时会接受任何JSON.parse 能接受的。 typetype 选项用来决定中间件要解析媒体类型。选项可以是一个函数或者是字符串。当为字符串时，可以直接通过type-is 库直接传递给选项，字符串也可以为一个扩展名（例如json）、mime 类型（application/json、/ 、*/json）。当为函数时：默认为application/json。 verifyverify选项，若缺失则为一个函数function（req,res,buf,encoding）,buf为一个Buffer。 bodyParse.raw(option)将请求体内容作为Buffer来处理，并返回。支持gzip deflate 压缩。 inflate limit type verify bodyParser.text(option)将请求提内容作为字符串来处理，并返回。支持gzip deflate 压缩。 defaultCharset若请求头未设置Content-Type则默认为utf8 inflate type verify bodyParser.urlencoded(option)中间件只解析urlencoded 请求体，并返回，只支持UTF-8编号文本，支持gzip deflate 压缩。 extend ture-&gt;使用queryString库（默认） false-&gt;使用qs库。 limit parameterlimit指定parameters最长长度，默认1000 type verify]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html中offsetTop、clientTop、scrollTop、offsetTop各属性介绍]]></title>
      <url>%2F2016%2F12%2F23%2Fhtml%E4%B8%ADoffsetTop%E3%80%81clientTop%E3%80%81scrollTop%E3%80%81offsetTop%E5%90%84%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidth scrollHeight: 获取对象的滚动高度。 scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 scrollWidth:获取对象的滚动宽度 offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度 offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 event.clientX 相对文档的水平座标 event.clientY 相对文档的垂直座标 event.offsetX 相对容器的水平坐标 event.offsetY 相对容器的垂直坐标 document.documentElement.scrollTop 垂直方向滚动的值 event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量 这里是JavaScript中建造迁移转变代码的常用属性 页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 网页可见区域宽： document.body.offsetWidth （包含边线的宽）; 网页可见区域高： document.body.offsetHeight （包含边线的宽）; 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 网页正文项目组上： window.screenTop; 网页正文项目组左： window.screenLeft; 屏幕辨别率的高： window.screen.height; 屏幕辨别率的宽： window.screen.width; 屏幕可用工作区高度： window.screen.availHeight; offset 假设 obj 为某个 HTML 控件。obj.offsetTop 指 obj 间隔上方或上层控件的地位，整型，单位像素。obj.offsetLeft 指 obj 间隔左方或上层控件的地位，整型，单位像素。obj.offsetWidth 指 obj 控件自身的宽度，整型，单位像素。obj.offsetHeight 指 obj 控件自身的高度，整型，单位像素。我们对前面提到的“上方或上层”与“左方或上层”控件作个申明。 例如：1234567&lt;div id="tool"&gt;&lt;input type="button" value="提交"&gt;&lt;input type="button" value="重置"&gt;&lt;/div&gt; “提交”按钮的 offsetTop 指“提交”按钮距“tool”层上边框的间隔，因为距其上边比来的是 “tool” 层的上边框。“重置”按钮的 offsetTop 指“重置”按钮距“tool”层上边框的间隔，因为距其上边比来的是 “tool” 层的上边框。“提交”按钮的 offsetLeft 指“提交”按钮距“tool”层左边框的间隔，因为距其左边比来的是 “tool” 层的左边框。“重置”按钮的 offsetLeft 指“重置”按钮距“提交”按钮右边框的间隔，因为距其左边比来的是“提交”按钮的右边框。 以上属性在 FireFox 中也有效。 另外：我们这里所说的是指 HTML 控件的属性值，并不是 document.body，document.body 的值在不合浏览器中有不合申明（实际上大多半景象是因为对 document.body 申明不合造成的，并不是因为对 offset 申明不合造成的），点击这里查看不合点。 题目：offsetTop 与 style.top 的差别 筹办常识：offsetTop、offsetLeft、offsetWidth、offsetHeight 我们知道 offsetTop 可以获得 HTML 元素间隔上方或外层元素的地位，style.top 也是可以的，二者的差别是： 一、offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。二、offsetTop 只读，而 style.top 可读写。三、若是没有给 HTML 元素指定过 top 样式，则 style.top 返回的是空字符串。 offsetLeft 与 style.left、offsetWidth 与 style.width、offsetHeight 与 style.height 也是同样事理。 题目：clientHeight、offsetHeight和scrollHeight 我们这里说说四种浏览器对 document.body 的 clientHeight、offsetHeight 和 scrollHeight 的申明，这里说的是 document.body，若是是 HTML 控件，则又有不合，点击这里查看。这四种浏览器分别为IE（Internet Explorer）、NS（Netscape）、Opera、FF（FireFox）。 clientHeight 大家对 clientHeight 都没有什么贰言，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个对象条以下到状况栏以上的这个区域，与页面内容无关。 offsetHeight IE、Opera 认为 offsetHeight = clientHeight + 迁移转变条 + 边框。 NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。 scrollHeight IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。 NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。 简单地说,clientHeight 就是透过浏览器看内容的这个区域高度。 NS、 FF 认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于便是 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。 IE、Opera 认为 offsetHeight 是可视区域 clientHeight 迁移转变条加边框。scrollHeight 则是网页内容实际高度。 同理clientWidth、offsetWidth 和 scrollWidth 的申明与上方雷同，只是把高度换成宽度即可。 然则FF 在不合的 DOCTYPE 中对 clientHeight 的申明不合， xhtml 1 trasitional 中则不是如上申明的。其它浏览器则不存在此题目。 题目：scrollTop、scrollLeft、scrollWidth、scrollHeight scrollTop 是“卷”起来的高度值，示例： 12345678910111213&lt;div style="width:100px;height:100px;background-color:＃FF0000;overflow:hidden;" id="p"&gt;&lt;div style="width:50px;height:300px;background-color:＃0000FF;" id="t"&gt;若是为 p 设置了 scrollTop，这些内容可能不会完全显示。&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var p = document.getElementById（"p"）;p.scrollTop = 10;&lt;/script&gt; 因为为外层元素 p 设置了 scrollTop，所以内层元素会向上卷。 scrollLeft 也是类似事理。 我们已经知道 offsetHeight 是自身元素的宽度。 而 scrollHeight 是内部元素的绝对宽度，包含内部元素的隐蔽的项目组。 上述中 p 的 scrollHeight 为 300，而 p 的 offsetHeight 为 100。 scrollWidth 也是类似事理。 IE 和 FireFox 周全支撑，而 Netscape 和 Opera 不支撑 scrollTop、scrollLeft（document.body 除外）。 揭晓时候：2007-10-15 20:20:16 题目：offsetTop、offsetLeft、offsetWidth、offsetHeight 返回对象的offsetLeft属性值和到当前窗口左边的真实值之间的间隔，可以懂得为边框的长度 一向以来对offsetLeft，offsetTop，scrollLeft，scrollTop这几个办法很含混，花了一天的时候好好的进修了一下．得出了以下的成果： - offsetTop: 当前对象到其上级层顶部的间隔. 不克不及对其进行赋值.设置对象到页面顶部的间隔请用style.top属性. - offsetLeft: 当前对象到其上级层左边的间隔. 不克不及对其进行赋值.设置对象到页面左部的间隔请用style.left属性. - offsetWidth: 当前对象的宽度. 与style.width属性的差别在于:如对象的宽度设定值为百分比宽度，则无论页面变大还是变小，style.width都返回此百分比，而offsetWidth则返回在不合页面中对象的宽度值而不是百分比值 - offsetHeight: 与style.height属性的差别在于:如对象的宽度设定值为百分比高度，则无论页面变大还是变小，style.height都返回此百分比，而offsetHeight则返回在不合页面中对象的高度值而不是百分比值 - offsetParent: 当前对象的上级层对象. 重视.若是对象是包含在一个DIV中时，此DIV不会被当做是此对象的上级层，（即对象的上级层会跳过DIV对象）上级层是Table时则不会有题目. 哄骗这个属性，可以获得当前对象在不合大小的页面中的绝对地位． 获得绝对地位脚本代码 123456789101112function GetPosition(obj)&#123; var left = 0; var top = 0; while(obj != document.body) &#123; left = obj.offsetLeft; top = obj.offsetTop; obj = obj.offsetParent; &#125; alert("Left Is : " + left + "\r\n" + "Top Is : " + top);&#125; scrollLeft : 对象的最左边到对象在当前窗口显示的局限内的左边的间隔． 便是在呈现了横向迁移转变条的景象下，迁移转变条拉动的间隔． scrollTop 对象的最顶部到对象在当前窗口显示的局限内的顶边的间隔． 便是在呈现了纵向迁移转变条的景象下，迁移转变条拉动的间隔． 我们这里说说四种浏览器对 document.body 的 clientHeight、offsetHeight 和 scrollHeight 的申明，这里说的是 document.body，若是是 HTML 控件，则又有不合，点击这里查看。 这四种浏览器分别为IE（Internet Explorer）、NS（Netscape）、Opera、FF（FireFox）。 clientHeight 大师对 clientHeight 都没有什么贰言，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个对象条以下到状况栏以上的这个区域，与页面内容无关。 offsetHeight IE、Opera 认为 offsetHeight = clientHeight + 迁移转变条 + 边框。 NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。 scrollHeight IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。 NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。 简单地说 clientHeight 就是透过浏览器看内容的这个区域高度。 NS、 FF 认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于便是 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。 IE、Opera 认为 offsetHeight 是可视区域 clientHeight 迁移转变条加边框。scrollHeight 则是网页内容实际高度。 同理 clientWidth、offsetWidth 和 scrollWidth 的申明与上方雷同，只是把高度换成宽度即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Formidable插件 API]]></title>
      <url>%2F2016%2F12%2F23%2FFormidable%E6%8F%92%E4%BB%B6%20API%2F</url>
      <content type="text"><![CDATA[创建Formidable.IncomingForm对象 1 var form = new formidable.IncomingForm() form.encoding = ‘utf-8’ 设置表单域的编码 form.uploadDir = “/my/dir”; 设置上传文件存放的文件夹，默认为系统的临时文件夹，可以使用fs.rename(先前的路径文件,改变后的路径文件)来改变上传文件的存放位置和文件名,当文件的目录一致的时候是修改的文件名字,当文件的目录的不一致的时候是移动文件 form.keepExtensions = false; 设置该属性为true可以使得上传的文件保持原来的文件的扩展名。 form.type 只读，根据请求的类型，取值’multipart’ or ‘urlencoded’ form.maxFieldsSize = 2 1024 1024; 限制所有存储表单字段域的大小（除去file字段），如果超出，则会触发error事件，默认为2M form.maxFields = 1000 设置可以转换多少查询字符串，默认为1000 form.hash = false; 设置上传文件的检验码，可以有两个取值’sha1’ or ‘md5’. form.multiples = false; 开启该功能，当调用form.parse()方法时，回调函数的files参数将会是一个file数组，数组每一个成员是一个File对象，此功能需要 html5中multiple特性支持。 form.bytesReceived 返回服务器已经接收到当前表单数据多少字节 form.bytesExpected 返回将要接收到当前表单所有数据的大小 form.parse(request, [callback]) 该方法会转换请求中所包含的表单数据，callback会包含所有字段域和文件信息，如： 123 form.parse(req, function(err, fields, files) &#123; // ... &#125;); form.onPart(part); 你可以重载处理multipart流的方法，这样做的话会禁止field和file事件的发生，你将不得不自己处理这些事情，如： 123456789101112 form.onPart = function(part) &#123; part.addListener(&apos;data&apos;, function() &#123; // ... &#125;); &#125;//如果你只想让formdable处理一部分事情，你可以这样做: form.onPart = function(part) &#123; if (!part.filename) &#123; // 让formidable处理所有非文件部分 form.handlePart(part); &#125; &#125; formidable.File对象 - file.size = 0 上传文件的大小，如果文件正在上传，表示已上传部分的大小 - file.path = null 上传文件的路径。如果不想让formidable产生一个临时文件夹，可以在fileBegain事件中修改路径 - file.name = null 上传文件的名字 - file.type = null 上传文件的mime类型 - file.lastModifiedDate = null 时间对象，上传文件最近一次被修改的时间 - file.hash = null 返回文件的hash值 - 可以使用JSON.stringify(file.toJSON())来格式化输出文件的信息无论是否上传图片,formidable都会默认传一个文件上去,当没有选择图片的时候,该文件的size为0 form.on(‘progress’, function(bytesReceived, bytesExpected) {});当有数据块被处理之后会触发该事件，对于创建进度条非常有用。 form.on(‘field’, function(name, value) {});每当一个字段/值对已经收到时会触发该事件 form.on(‘fileBegin’, function(name, file) {});在post流中检测到任意一个新的文件便会触发该事件 form.on(‘file’, function(name, file) {});每当有一对字段/文件已经接收到，便会触发该事件 form.on(‘error’, function(err) {});当上传流中出现错误便会触发该事件，当出现错误时，若想要继续触发request的data事件，则必须手动调用request.resume()方法 form.on(‘aborted’, function() {});当用户中止请求时会触发该事件，socket中的timeout和close事件也会触发该事件，当该事件触发之后，error事件也会触发 form.on(‘end’, function() {});当所有的请求已经接收到，并且所有的文件都已上传到服务器中，该事件会触发。此时可以发送请求到客户端。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas学习笔记 04]]></title>
      <url>%2F2016%2F11%2F21%2Fcanvas%2004%2F</url>
      <content type="text"><![CDATA[canvas 04 requestAnimationFrame:这个函数实际上是setTimeout的另类版本,使用方式和setTimeout几乎一致区别在于setTimeout可以自由指定回调的执行时机,而requestAnimationFrame不有指定执行时机,当浏览器重绘页面之前会尝试执行传入requestAnimationFrame的回调函数,也就是所传入requestAnimationFrame的时机与页面重绘几乎同时,这个函数主要是为了开发流畅的动画优点:requestAnimationFrame调用的时候帧数更稳定,比setTimeout更好,流畅.缺点:有兼容性问题.IE8 12345678910111213141516171819202122232425262728293031/** * requestAnimationFrame兼容性扩展，两方面工作： * 1、把各浏览器前缀进行统一 * 2、在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法 * */ (function() &#123; var lastTime = 0; var vendors = [&quot;webkit&quot;, &quot;moz&quot;]; for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x] + &quot;RequestAnimationFrame&quot;]; // Webkit中此取消方法的名字变了 window.cancelAnimationFrame = window[vendors[x] + &quot;CancelAnimationFrame&quot;] || window[vendors[x] + &quot;CancelRequestAnimationFrame&quot;]; &#125; if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16.7 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; &#125; if (!window.cancelAnimationFrame) &#123; window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;; &#125; &#125;()); 停止动画:可以考虑使用布尔类型变量进行判断,类似于递归的条件判断 ctx.arcTo(控制点1的x轴坐标,控制点1的y轴坐标,控制点2的x轴坐标,控制点2的y轴坐标,半径)注意:arcTo绘制弧,不需要圆心坐标.不需要起始位置和结束位置示例: ctx.moveTo(10,10);ctx.arcTo(210,10,210,100,200);ctx.stroke(); toDataURL如果导出的图片格式为jpeg,可以指定第二个参数,设置图片的压缩率cvs.toDataURL(“image/jpeg”,0.5);png是高保真图片格式,无法设置压缩率用法:传给图片的src即可使用场景:一个网站如果小图片不多,可以考虑使用.如果小图片比较多,可以优先使用精灵图,如果大图多,延迟加载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas学习笔记 03]]></title>
      <url>%2F2016%2F11%2F20%2Fcanvas%2003%2F</url>
      <content type="text"><![CDATA[canvas 03 ctx.translate(x轴平移多少,y轴平移多少)注意:平移的是画布坐标系,平移后不会影响到之前绘画的内容.平移可以累加 ctx.rotate(旋转的弧度)注意:旋转的是画布坐标系,旋转基点是画布的(0,0)点.旋转后不会影响到之前绘画的内容.旋转可以累加,参数正数的时候是顺时针旋转 ctx.scale(x轴缩放多少倍,y轴缩放多少倍)注意:缩放的的是画布坐标系,缩放后不会影响到之前绘画的内容.缩放可以累加 状态保存与回滚 状态:是指绘制上下文所有的属性值,即ctx下的全部属性 状态保存 ctx.save():就是把ctx对象当前所有的属性值进 行备份(复制一份存储起来).++状态保存与路径无关,save不会保存页面的路径++ 状态回滚 ctx.restore():就是把之前的备份的状态取出来,作为 当前状态使用多次备份与回滚:多次取的时候,是按照保存的倒序来取,也就是第一次取的是最后一次保存的,以此类推. 路径点判断ctx.isPointInPath(要判断的点x坐标,要判断的点y坐标),返回的是true/false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas学习笔记 02]]></title>
      <url>%2F2016%2F11%2F18%2Fcanvas%2002%2F</url>
      <content type="text"><![CDATA[canvas 02 绘制文字 描边文字ctx.strokeText(“要绘制的文字”,x轴坐标,y轴坐标,限制文字绘制时占用的最大长度(可选)) 填充文字ctx.fillText(“要绘制的文字”,x轴坐标,y轴坐标,限制文字绘制时占用的最大长度(可选)) 设置文字样式ctx.font=”900 20px 微软雅黑”和CSS语法一样,必须加单位,字体也必须写才能生效 设置文字水平对齐方式ctx.textAlign=”left/start”||”center”||”right/end”参考点为设置文字的起始点,左对齐就是从右向左靠拢,会显示在参考点的右边;右对齐就是从左往右靠拢,会显示在参考点的左边 设置文字水平对齐方式ctx.textBaseline=”top”||”middle”||”bottom”||”alphabetic”||”hanging||”ideographic”,默认为alphabetic.同样的,参考点为设置文字的起始点,top就是把参考点放在上面,bottom就是把参考点放在下面,因此在使用的时候和平时的感觉不太一样,bottom是往下移动,top是往上移动 预测量文字ctx.measureText(“被测量的文字”)预测一段文字,按照当前文字的字体的大小,绘制时要占用多宽多高,现在浏览器只能测试文字所占用的宽度,返回值是一个对象,目前这个对象只有width属性 绘制扇形 利用的是绘制弧线的时候,会从原先的路径连接到弧的起点,然后用closePath闭合,形成扇形 步骤: ctx.moveTo(圆心x,y) ctx.arc()以圆心为基准点 ctx.closePath(); ctx.stroke(); 如果是直接填充fill(),canvas会自动closePath() 绘制饼图 function(ctx,data,x,y,r){} ctx 上下文 data 数据 x,y 圆心坐标 半径 创建img元素的3种方式 html new Image() document.createElement(“img”) 绘制图像 ctx.drawImage(要绘制的图像资源,图像绘制到画布的X轴坐标,图像绘制到画布的y轴坐标)在绘制过程中,如果不加任何条件,是异步加载,在下载图片资源的同时就会开始进行绘制,所以会导致无法正常显示,建议用事件监听来控制 img.onload=funciton(){ctx.drawImage(img,x,y)} ctx.drawImage(要绘制的图像资源,图像绘制到画布的X轴坐标,图像绘制到画布的y轴坐标,指定图像绘制的宽度,指定图像绘制的高度) ctx.drawImage(要绘制的图像资源,裁剪的起始x轴坐标,裁剪的起始y轴坐标,裁剪多宽,裁剪多高,x轴坐标,y轴坐标,指定图像绘制的宽度,指定图像绘制的高度)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas学习笔记 01]]></title>
      <url>%2F2016%2F11%2F17%2Fcanvas%2001%2F</url>
      <content type="text"><![CDATA[canvas 01 canvas作用: 游戏 数据可视化(图表) 环境的含义:一个东西赖以生存的绘图环境:绘制图形所需的东西路径是一个图形的轮廓,是对将来要绘制图形的一个规划让路径最终生效需要描边canvas通过js来绘制 需要获取一个绘图环境 通过canvasDOM元素提供的一个方法getContextcvx=document.querySelector(“canvas”);ctx=cvs.getContext(“2d”||”wgbgl”)(在这里一般用2d) 绘图图形: 先移动钢笔到指定的位置(图形的起始位置)ctx.moveTo(二维坐标); 画图形的路径ctx.lineTo(二维坐标); 描边ctx.stroke(不用填); 动态设置画布大小(默认300*150) canvasDOM对象有width和height属性 canvas绘制的是位图(像素图),默认单位px,设置的时候不用加单位 动态设置大小会清除画布的内容 不要设置canvas样式中的宽高,因为会拉伸 基于状态(属性值) 根据属性的变化,表现出来的结果不一样 描边色 ctx.strokeStyle=””支持所有颜色表示方式,修改描边色之后,一些和描边相关的方法,再次调用时候相关方法都会受影响(多次描边会叠加) 清除路径(开辟新路径) ctx.beginPath(不用填) 开辟新的路径,避免重复描边 路径是看不见的,描边过的清除路径并不会影响已经描边的情况 线宽 ctx.lineWidth=(不要单位) 闭合路径 ctx.closePath(不用填); 最后一条路径不用写 设置填充 ctx.fill();调用的方法 ctx.fillStyle=””;设置填充样式 填充和描边的顺序: 先填充后描边可以显示出真正的描边宽度 先描边后填充,填充部分会占用一般的描边宽度,因为描边的时候是沿着边框,里外各一半宽度 非零环绕原型: 作用:用来判断路径围起来的区域是否在路径内 原理: 在路径包含的区域内随便找一点向外发射一条线,让这条线贯穿所有围绕该点的路径 开启一个计数器,初始值为0 遇到顺时针围绕点的路径,数+1 逆时针,数-1 最终结果不是0,可以认为这块区域在路径包含之内 清除整个画布ctx.clearRect(起点坐标x,起点坐标y,宽,高) 画矩形路径ctx.rect(起始x轴,起始y轴,宽(正负代表方向),高(正负代表方向)) 绘制描边矩形(不产生路径)ctx.strokeRect(起始x轴,起始y轴,宽,高),该方法不产生路径,所以fill方法无效 绘制填充矩形(不产生路径)ctx.fillRect(起始x轴,起始y轴,宽,高) 线帽样式ctx.lineCap=”butt”||”round”||”square”.默认值butt round 圆头,两端也加长了线宽的一半 square 是两端各加长线宽的一半 交点样式(两条线交点处的样式)ctx.lineJoin=”miter”(尖头)||”round”(圆头)||”bevel”(斜面).默认为mitermiterlimit(尖头最大长度,默认10) 虚线绘制ctx.setLineDash([5,5])(实线长度,虚线长度). 参数可以写很多,都是实线.虚线的顺序 参数可以写奇数个,实线虚线交替,轮到谁就是谁,不再固定指谁是实线长度谁是虚线长度 ctx.getLineDash,获取虚线设置 关于路径起点的设置 正常情况通过moveTo来设置 如果之前没有任何路径和路径的起点,那么第一个lineTo相当于moveTo 画弧路径ctx.arc(圆心x轴坐标,圆心y轴坐标,半径,弧的起始位置,弧的结束位置,是否逆时针画(可选,默认顺时针,false));传的是弧度,可用一个函数来转换为度数Math.PI/180*度数]]></content>
    </entry>

    
  
  
</search>
