<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[React学习笔记01 - 概念和配置]]></title>
      <url>%2F2017%2F01%2F16%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2001%2F</url>
      <content type="text"><![CDATA[React四大概念 Virtual DOM(虚拟DOM) 目的 提升性能在React中，应用程序在虚拟DOM上操作，这让React有了优化的机会。简单说， React在每次需要渲染时，会先比较当前DOM内容和待渲染内容的差异， 然后再决定如何最优地更新DOM 兼容性因为有了虚拟DOM这一层，所以通过配备不同的渲染器，就可以将虚拟DOM的内容 渲染到不同的平台。而应用开发者，使用JavaScript就可以通吃各个平台了。 组件化概念将UI分成不同的组件，每个组件都独立封装。 特性: 可组合 可重用 可维护 可测试 Jsx语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写.只是利用JSX，组件的结 构和组件之间的关系看上去更加清晰 1234567891011var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')); 上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析 Data Flow（单向数据流） React快速开始 创建项目文件夹 1npm init // 初始化npm配置文件 依赖环境 1npm install react react-dom --save 创建目录结构 开始123456789//固定写法,导入react和react-dom模块var React=require(‘react’);var ReactDOM=require(‘react-dom’);var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render(&lt;HelloMessage name="John" /&gt;, mountNode);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React学习笔记02 - JSX和API]]></title>
      <url>%2F2017%2F01%2F16%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2002%2F</url>
      <content type="text"><![CDATA[JSX 自定义html属性 如果在 JSX 中使用的属性不存在于 HTML 的规范中，这个属性会被忽略。如果要使用自定义属性，可以用 data- 前缀 支持的标签和属性 如果你要使用的某些标签或属性不在这些支持列表里面就可能被 React 忽略 支持列表：http://reactjs.cn/react/docs/tags-and-attributes.html 并不是所有的html标签和属性都能在jsx语法中使用 基本上你能用到的标签的属性，jsx语法都支持 有些特殊的属性需要注意，所有的属性都是驼峰命名的，class 属性和 for 属性分别改为 className 和 htmlFor，来符合 DOM API 规范。 属性扩散需求:需要给组件设置多个属性，你不想一个个写下这些属性，或者有时候你甚至不知道这些属性的名称 1234var props = &#123;&#125;;props.foo = x;props.bar = y;var component = &lt;Component &#123;...props&#125; /&gt;; 属性也可以被覆盖，写在后面的属性值会覆盖前面的属性 123var props = &#123; foo: &apos;default&apos; &#125;;var component = &lt;Component &#123;...props&#125; foo=&#123;&apos;override&apos;&#125; /&gt;;console.log(component.props.foo); // &apos;override&apos; 自闭合标签如果只有一个组件，就用单闭合标签形式，如果有多个组件嵌套就用双闭合标签形式 注释在 JSX 里使用注释也很简单，就是沿用 JavaScript，唯一要注意的是在一个组件的子元素位置使用注释要用 {} 包起来 12345//两种注释的方法&#123;/* child comment, put &#123;&#125; around */&#125;&#123; // end of line comment&#125; API 顶层api(常用) ReactReact 是 React 库的入口。如果使用的是预编译包，则 React 是全局的；如果使用 CommonJS 模块系统，则可以用 require() 函数引入 React。 React.createClass 1ReactClass createClass(object specification) 创建一个组件类，并作出定义。组件实现了 render() 方法，该方法返回一个子级 React.createElement 12345ReactElement createElement( string/ReactClass type, [object props], [children ...]) 创建并返回一个新的指定类型的 ReactElement。type参数可以是一个 html 标签名字字符串（例如，“div”，“span”，等等），或者是 ReactClass （通过 React.createClass 创建的）。 React.render 12345ReactComponent render( ReactElement element, DOMElement container, [function callback]) 渲染一个 ReactElement 到 DOM 中，放在 container 指定的 DOM 元素下，返回一个到该组件的引用。如果 ReactElement 之前就被渲染到了 container 中，该函数将会更新此 ReactElement，仅改变需要改变的 DOM 节点以展示最新的 React 组件。如果提供了可选的回调函数，则该函数将会在组件渲染或者更新之后调用。 组件api 设置状态：setState 1setState(object nextState[, function callback]) 参数说明 nextState，将要设置的新状态，该状态会和当前的state合并 callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。 合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。 替换状态：replaceState 1replaceState(object nextState[, function callback]) nextState，将要设置的新状态，该状态会替换当前的state。 callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。 replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。 设置属性setProps 1setProps(object nextProps[, function callback]) nextProps，将要设置的新属性，该状态会和当前的props合并 callback，可选参数，回调函数。该函数会在setProps设置成功，且组件重新渲染后调用。 设置组件属性，并重新渲染组件。 props相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。 更新组件，我可以在节点上再次调用React.render()，也可以通过setProps()方法改变组件属性，触发组件重新渲染。 替换属性replaceProps 1replaceProps(object nextProps[, function callback]) nextProps，将要设置的新属性，该属性会替换当前的props。 callback，可选参数，回调函数。该函数会在replaceProps设置成功，且组件重新渲染后调用。 replaceProps()方法与setProps类似，但它会删除原有props 强制更新：forceUpdate 1forceUpdate([function callback]) 参数说明 callback，可选参数，回调函数。该函数会在组件render()方法调用后调用。 forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render()。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。forceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render() 一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。 获取DOM节点：findDOMNode 1DOMElement findDOMNode() 返回值：DOM元素DOMElement 如果组件已经挂载到DOM中，该方法返回对应的本地浏览器 DOM 元素。当render返回null 或 false时，this.findDOMNode()也会返回null。从DOM 中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM 操作。 判断组件挂载状态：isMounted 1bool isMounted() 返回值：true或false，表示组件是否已挂载到DOM中 isMounted()方法用于判断组件是否已挂载到DOM中。可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie和session以及node相关的中间件使用]]></title>
      <url>%2F2016%2F12%2F29%2Fcookie%E5%92%8Csession%E4%BB%A5%E5%8F%8Anode%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[原生属性概念 HTTP协议与状态保持：Http是一个无状态协议 实现状态保持的方案： 修改Http协议，使得它支持状态保持(难做到) Cookies：通过客户端来保持状态信息 Cookie是服务器发给客户端的特殊信息 cookie是以文本的方式保存在客户端，每次请求时都带上它 Session：通过服务器端来保持状态信息 Session是服务器和客户端之间的一系列的交互动作 服务器为每个客户端开辟内存空间，从而保持状态信息.由于需要客户端也要持有一个标识(id)，因此，也要求服务器端和客户端传输该标识,标识(id)可以借助Cookie机制或者其他的途径来保存 COOKIE机制 Cookie的基本特点 Cookie保存在客户端 只能保存字符串对象，不能保存对象类型 需要客户端浏览器的支持：客户端可以不支持，浏览器用户可能会禁用Cookie 采用Cookie需要解决的问题 Cookie的创建 通常是在服务器端创建的(当然也可以通过javascript来创建) 服务器通过在http的响应头加上特殊的指示，那么浏览器在读取这个指示后就会生成相应的cookie了 Cookie存放的内容 业务信息(“key”,”value”) 过期时间 域和路径 浏览器是如何通过Cookie和服务器通信 通过请求与响应，cookie在服务器和客户端之间传递 每次请求和响应都把cookie信息加载到响应头中；依靠cookie的key传递。 cookie的创建 express直接提供了api,只需要在需要使用的地方调用如下api即可 12345function(req, res, next)&#123; ... res.cookie(name, value [, options]); ...&#125; express就会将其填入Response Header中的Set-Cookie，达到在浏览器中设置cookie的作用。 name: 类型为String value: 类型为String和Object，如果是Object会在cookie.serialize()之前自动调用JSON.stringify对其进行处理 Option: 类型为对象，可使用的属性如下 domain：cookie在什么域名下有效，类型为String,。默认为网站域名 expires: cookie过期时间，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。 httpOnly: 只能被webserver访问，类型Boolean。 maxAge: 实现expires的功能，设置cookie过期的时间，类型为String，指明从现在开始，多少毫秒以后，cookie到期。 path: cookie在什么路径下有效，默认为’/‘，类型为String,匹配该路径才发送这个 cookie。 secure：只能被HTTPS使用，类型Boolean，默认为false signed:使用签名，类型Boolean，默认为false。express会使用req.secret来完成签名，需要cookie-parser配合使用` 1234567891011res.cookie('name', 'koby', &#123; domain: '.example.com', path: '/admin', secure: true &#125;);//cookie的有效期为900000msres.cookie('rememberme', '1', &#123; expires: new Date(Date.now() + 900000), httpOnly: true &#125;);//cookie的有效期为900000msres.cookie('rememberme', '1', &#123; maxAge: 900000, httpOnly: true &#125;);//cookie的value为对象 res.cookie('cart', &#123; items: [1,2,3] &#125;);res.cookie('cart', &#123; items: [1,2,3] &#125;, &#123; maxAge: 900000 &#125;);res.cookie('name', 'tobi', &#123; signed: true &#125;); cookie的删除 express直接提供了api删除浏览器中的cookie,只需要在需要使用的地方调用如下api即可 12345function(req, res, next)&#123; ... res.clearCookie(name [, options]); ...&#125; session cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。 session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 connect.sid 这个字段，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。 这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid 字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。 session 可以存放在 内存、 cookie本身 redis 或 memcached 等缓存中 数据库线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐；cookie session 有安全性问题. 工作流程:当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)。 客户的信息都保存在session中。 创建session可以概括为三个步骤： 生成全局唯一标识符（sessionid）； 开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享； 将session的全局唯一标示符发送给客户端。问题的关键就在服务端如何发送这个session的唯一标识上。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：cookie和URL重写。 cookie-parser利用cookie-parser读取cookie npm安装命令 1$npm install cookie-parser --save 使用方式 123456789var express = require(&apos;express&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var app = express();//不使用签名app.use(cookiePareser());//若需要使用签名，需要指定一个secret,字符串,否者会报错app.use(cookiePareser(&apos;Simon&apos;)); 如果没有为signed功能，cookie-parser通过如下代码解析req.headers.cookie 1234567891011121314151617181920212223242526272829303132333435363738394041 //index.js var cookie = require(&apos;cookie&apos;); var parse = require(&apos;./lib/parse&apos;); if (req.cookies) return next(); //如果存在req.cookies跳过这个middleware var cookies = req.headers.cookie; //保存对象地址，提高运行效率 req.cookies = Object.create(null); //创建一个对象，解析后的且未使用签名的cookie保存在req.cookies中 req.cookies = cookie.parse(cookies); //与express中调用cookie.serialize()对应，解析cookie req.cookies = JSONCookies(req.cookies); // JSON字符序列转化为JSON对象 //./lib/parse.js //接续cookie中的JSON字符序列 exports.JSONCookies = function(obj)&#123; var cookies = Object.keys(obj); //获取obj对象的property var key; var val; //循环判断并解析 for (var i = 0; i &lt; cookies.length; i++) &#123; key = cookies[i]; val = exports.JSONCookie(obj[key]); //如果是JSON字符序列则保存 if (val) &#123; obj[key] = val; &#125; &#125; return obj; &#125;; //解析JSON字符序列 exports.JSONCookie = function(str) &#123; if (!str || str.substr(0, 2) !== &apos;j:&apos;) return; //判断是否为JSON字符序列，如果不是返回undefined try &#123; return JSON.parse(str.slice(2)); //解析JSON字符序列 &#125; catch (err) &#123; // no op &#125; &#125;; 如果使用了signed功能，cookie-parser通过如下代码解析req.headers.cookie 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//index.jsvar cookie = require(&apos;cookie&apos;);var parse = require(&apos;./lib/parse&apos;);if (req.cookies) return next(); //如果存在req.cookies跳过这个middleware//调用res.cookie(name, value , &#123;singed: true&#125;)，express会使用req.secret。故使用了签名功能，需给cookie-parser传递secret，且res.cookie(name, value , &#123;singed: true&#125;)需在cookie-parser插 //入express后再使用req.secret = secret; req.cookies = Object.create(null);req.signedCookies = Object.create(null); //创建req.singedCookies，所有解析后的signed cookie都保存在这个对象中，req.cookies中没有任何signed cookie// 如果请求中没有cookiesif (!cookies) &#123; return next();&#125;req.cookies = cookie.parse(cookies, options); //与express中调用cookie.serialize()对应，解析cookie// parse signed cookiesif (secret) &#123; //判断是否为singed cookie。如果是，则去掉签名，同时删除req.cookies中对应的property，将这些去掉签名的cookie组成一个对象，保存在req.signedCookies中 req.signedCookies = parse.signedCookies(req.cookies, secret); // JSON字符序列转化为JSON对象 req.signedCookies = parse.JSONCookies(req.signedCookies); &#125;//./lib/parse.jsvar signature = require(&apos;cookie-signature&apos;);exports.signedCookies = function(obj, secret)&#123; var cookies = Object.keys(obj); //获取obj对象的property var dec; var key; var ret = Object.create(null); //创建返回对象 var val; for (var i = 0; i &lt; cookies.length; i++) &#123; key = cookies[i]; val = obj[key]; dec = exports.signedCookie(val, secret); //判断是否是去掉签名后的value，如果是保存该值到ret中同时删除obj中的相应property if (val !== dec) &#123; ret[key] = dec; delete obj[key]; &#125; &#125; return ret;&#125;;exports.signedCookie = function(str, secret)&#123; //判断是否添加了签名，如果添加了签名则去掉签名，否则返回原字符串 return str.substr(0, 2) === &apos;s:&apos; ? signature.unsign(str.slice(2), secret) : str;&#125;; 综上所诉，解析后的unsigned cookie保存在req.cookies中，而解析后的signed cookie只保存在req.signedCookies中。使用cookie-parser插件，后续代码直接使用req.cookies或者req.signedCookies即可 cookie-parser简单实用 实例: 1234567891011121314151617181920212223var express = require(&apos;express&apos;);// 首先引入 cookie-parser 这个模块var cookieParser = require(&apos;cookie-parser&apos;);var app = express();app.listen(3000);// 使用 cookieParser 中间件，cookieParser(secret, options)// 其中 secret 用来加密 cookie 字符串（下面会提到 signedCookies）// options 传入上面介绍的 cookie 可选参数app.use(cookieParser());app.get(&apos;/&apos;, function (req, res) &#123;// 如果请求中的 cookie 存在 isVisit, 则输出 cookie// 否则，设置 cookie 字段 isVisit, 并设置过期时间为1分钟if (req.cookies.isVisit) &#123; console.log(req.cookies); res.send(&quot;再次欢迎访问&quot;); &#125; else &#123; res.cookie(&apos;isVisit&apos;, 1, &#123;maxAge: 60 * 1000&#125;); res.send(&quot;欢迎第一次访问&quot;); &#125;&#125;); express-session 方法就是 session(options)，其中 options 中包含可选参数，主要有： name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid 。可以认为,这个就是cookie的name store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。 secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。 cookie: 设置存放 session id 的 cookie 的相关选项，默认为 1(default: &#123; path: &apos;/&apos;, httpOnly: true, secure: false, maxAge: null &#125;) genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 uid2 这个 npm 包。 rolling: 每个请求都重新设置一个 cookie，默认为 false。 resave: 即使 session 没有被修改，也保存 session 值，默认为 true。 只需要用express app的use方法将session挂载在‘/’路径即可，这样所有的路由都可以访问到session。可以给要挂载的session传递不同的option参数，来控制session的不同特性. 一旦我们将express-session中间件用use挂载后，我们可以很方便的通过req参数来存储和访问session对象的数据。req.session是一个JSON格式的JavaScript对象，我们可以在使用的过程中随意的增加成员，这些成员会自动的被保存到option参数指定的地方，默认即为内存中去。 示例: 12345678910111213141516171819202122232425var express = require(&apos;express&apos;);// 首先引入 express-session 这个模块var session = require(&apos;express-session&apos;);var app = express();app.listen(5000);// 按照上面的解释，设置 session 的可选参数app.use(session(&#123; secret: &apos;recommand 128 bytes random string&apos;, // 建议使用 128个字符的随机字符串 cookie: &#123; maxAge: 60 * 1000 &#125;&#125;));app.get(&apos;/&apos;, function (req, res) &#123; // 检查 session 中的 isVisit 字段 // 如果存在则增加一次，否则为 session 设置 isVisit 字段，并初始化为 1。if(req.session.isVisit) &#123; req.session.isVisit++; res.send(&apos;&lt;p&gt;第 &apos; + req.session.isVisit + &apos;次来此页面&lt;/p&gt;&apos;);&#125; else &#123; req.session.isVisit = 1; res.send(&quot;欢迎第一次来这里&quot;); console.log(req.session); &#125;&#125;); 个人体会:整体流程应该是这样子的: 首先,服务器端创建了cookie,并要传给浏览器,这样浏览器下次再来访问的时候,带上cookie存储的相关信息,就可以达到保存状态的目的 但是需要给请求也就是req挂上相应的信息才行.用了中间件cookie.parser之后,插件自动帮你挂上了这个请求信息,通过处理将信息转化为了一个json对象,不用自己手动添加了 但是考虑到cookie的诸多安全性问题,需要用session将具体的状态信息保存在服务器端,此时用express-session插件,会给每个不同的访问创建一个key-val的json信息对,key返回给浏览器,而最关键的val保存在服务器,浏览器每次访问的时候,req都会带着key去访问,服务器凭借key去找val,服务器将val返回给浏览器.这样就一定程度上保证了安全性 如有错误,敬请指正]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你的名字 - 观后所思所想]]></title>
      <url>%2F2016%2F12%2F24%2F%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为一个已经宅龄颇大的二次元爱好者,在渐渐踏入社会之后,与二次元的距离也是越来越远.见证了二次元从小众到如今泛二次元的大众化,从以前的不受待见,到这部&lt;你的名字&gt;声势浩大的进入大陆市场, 有些不慎唏嘘.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里,我并不是很想去谈关于这部电影的好坏优劣,抑或和网上的影评去争论什么,单纯想谈谈动漫这个圈子,简单的回忆些以前的事情. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我一直觉得,作品需要观众,而观众也需要作品,当两者契合之时,那就是遇见了对的事情.就如一千个人心中有一千部哈姆雷特一样,每个人从出生起,对这个世界,对自己,对周边事物的认知就是有着区别的.好的作品,或者说”神作”这个词,在每个人的心目中有着不同的标准.作品见得多了,有时候也感觉自己有些老油条了,渐渐的对待作品,只会从人设,剧情,音乐等多方面去综合评价,最后得出一个看似客观而权威的判断,以自己资历深而沾沾自喜.可是,我回想,自己看动漫的初衷是什么呢?是炫耀?是打发时间?还是为了看而看? &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的过去曾经经历过这些:为了看的多而看,为了体现自己自己阅历广.资历深去看作品,强迫自己看了一大堆作品,最后往往发现,自己对那些作品并没有什么印象,也最多是事后提起来,说主角是什么,剧情是什么云云.其实现在想起来,这是在浪费自己的时间.一个作品,无论好坏,我觉得一定要以最认真的态度去看.你真的想看,再看,去认真感受. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;共鸣,是一个作品的灵魂,我是这么觉得的.只有作品与你的心境产生了共鸣之时,就好比遇上了对的人,此刻,我想对于作品和观众,都是幸运的.在茫茫的作品与茫茫的人海中,彼此的相遇也是一种缘分.我一直珍惜那些在我心里引起共鸣的作品,这些作品连带着我看时的心情,都化作了回忆,留藏在心里.有时候,回想起那部作品,就想起了彼时的自己,想起了过去的人生,那是一种奇妙的心情. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好比&lt;时间都去哪了&gt;这首歌,让多少忙忙碌碌度过漫长岁月的人听了泪流满面,&lt;秒速五厘米&gt;的最后的错过,让多少人想起了自己的初恋.当一个作品,击中了你心中某些柔软的东西,才会让你铭记深刻.有无数部作品都击中过我的心灵,让我感动过,让我为之共鸣,恋恋不忘,对我来说,这也是一种幸运. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不刻意贬低一个作品,不刻意神话一部作品,不以小众而孤芳自赏,不以大众而谓之烂俗,看作品之前不要看剧透,不要问别人的看法;喜欢的作品,推荐给别人没有得到意想之中的回应时不要愤怒;不要强迫别人为你喜欢的作品说好,不要随意的判定一部作品,认真的看待每一部作品.以上的这些,已经成为了我作为一个二次元爱好者的一些准则,我相信每部作品都有着灵魂,如果我触摸不到,只能说我俩频率不对.是否能对上频率,这就需要缘分了.比如cl的一致好评,为什么?是因为亲情友情爱情,对于大部分人来说,都是一个美好的东西,而cl正是体现出了这些简简单单的东西也有着让人弥足珍贵的理由.为什么有些人喜欢那朵花?虽然这部作品个人有着一些不同的看法,并没有触及到我的心灵深处,但我想对于那群喜爱他的观众来说,童年时期的友情和一些情愫让人留恋.石头门那无数条世界线上的冈部伦太郎,为了改变青梅竹马死亡命运的努力,和牧濑红莉栖彼此的默契信任,又感动了多少人?一句没有你的四月就要到了,又让多少人留下了眼泪?很多作品,让人不能释怀,我想必然是你能体会出其中某些美好的东西.理解一部作品就像恋人之间的相互理解一样,有些事情,不需勉强.不为别人叫好而叫好,抱着不同意见也不必强迫对方去接受,每个人体会自己的感受到的美好,这就够了.二次元这种东西,不应该是我们心灵的栖息地么,不要太多俗世气息去沾染它,争吵,互黑,真的没必要. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然日渐忙碌,心中杂虑渐多,所思所想有时候也夜不能寐,生活渐渐复杂.但是,我自己的心中,永远保留着那一片纯净的地域,那就是对待二次元的心,有时候,停下脚步,偶得一部佳作,也是人生乐事. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;羡慕过去的自己,能够拥有大把的时间和纯净的心情去对待每一部作品,也不会忘记,这么多年来那些足以在我岁月中留下刻痕的作品. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后说一下,一个能让很久没写东西的我想了这么多,敲打了这些字的作品,怎么说,也不会差吧,也推荐大家可以去看看. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;————很久没写东西,词不达意,意不能表之处,请多多包涵]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git常用指令和流程]]></title>
      <url>%2F2016%2F12%2F24%2Fgit%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支 新建一个分支，开发注册功能 新建一个 register.html 新建一个 register.css 修改 index.html ，增加一个 a 链接，链接到 register.html 基于该分支提交修改 开发完毕，再把该分支合并到 master 中 合并后，将 原来的分支删除 分支存在的意义 单人开发毫无意义 只有多人协作才能体现出分支的价值 什么时候去创建分支、什么时候合并分支 团队之间如何正确的使用 Git 分布式 不需要联网就可以在本地生成历史记录 即便你的服务器宕机了，仓库的历史记录永远不会丢失123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] rmdir 目录名称 注意：只能删除空目录 rm 文件名 可以用来删除指定文件 rm -rf 目录名称 可以用来删除一个非空目录 mkdir 目录名称 cd 目录名称 mkdir 目录名称 &amp;&amp; cd 目录名称 vi 编辑器 它是一个命令行编辑器 vim 是 vi 的一个高级版 两个都是一个东西 Visual Interface 可视化接口 vi 文件名 使用 vi 编辑指定文件 默认会进入命令模式 将光标移动到要编辑的位置，输入字母 i 进入编辑模式 注意：千万不要乱打键盘，因为在 vi 中，默认是命令模式，各个字母都表示不同的命令 编辑完毕之后，可以按 Esc 退出编辑模式，进入命令模式 然后直接输入 :w 回车保存编辑 如何退出：:q 退出 vi 如果修改了，但是不想保存，可以直接 :q! 强制退出 如果想要快捷保存修改，则可以 :wq 保存并退出 标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 远程同步远程操作假设，项目立项了，要开始开发了，领导选择了使用 Git 作为版本管理工具，会有一个核心人员（有一定版本管理工具使用经验）当作源代码仓库管理员，它去创建一个远程仓库，然后做一些基础设施，例如项目结构初始化（做一些开发约定）。 第一天到公司之后，别人会告诉你它们使用的哪个版本管理工具，然后会告诉你该版本仓库的地址：https://github.com/jtbsk/example.git ，你这个时候拿到这个地址然后去 clone 就可以了。这个 clone 也不是任何人都可以 clone 的，公司内部的项目一般都私有的，有权限认证，如果它把地址给你了，但是你 clone 的时候可能会报错（权限错误），如果是权限错误，可能是管理员没有给你添加权限，那这个时候，你跟管理员说一下，帮你添加一个操作权限，然后你再去 clone。 没有远程仓库，本地有：需求就是把本地的仓库放到远程加入你现在在教室，没有网络，但是你要开发一个项目，从来没有被 Git 管理过，则可以直接通过 git init 的形式在你的项目中使用 Git。 先去远端创建一个仓库 接下来通过 git remote add 给远端地址起个短一点的有意义的别名 远端地址 可以通过 git remote 查看所有的远端地址，默认只能看到别名 可以通过 git remote show 远端地址别名 查看某个具体的远端地址信息 然后通过 git push 远端地址别名 要提交到的分支名称 上面的步骤以后每次 push 都需要制定 remote name 为了方便，你可以在 push 的时候，直接通过 git push --set-upstream 远端地址名 分支 使用了该命令提交之后 以后就可以直接 git push 的方式提交了，因为 –set-upstream 就是用来记住你的那个 remote 的 已有远程仓库，直接通过 clone 来拿就可以了 先在远端创建一个仓库 然后通过 clone 的形式克隆到本地 通过 clone 的形式下载下来的仓库默认会创建一个 remote ，名字叫 origin，这是 Git 的默认行为 通过会自动为 push 和 origin 之间建立一个上下游关系 该关系就意味着 每一次使用 git push 的时候，不需要指定 后面的 origin 了 然后再通过 push-pull 的形式推送和拉取源代码1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 多人协作Collaborators 简单粗暴 直接把协作者添加到仓库的权限列表中 项目页面 -&gt; Settings -&gt; Collaborators -&gt; 添加协作者 协作者会收到一封 email ，然后点进去收到一封邮件，同意成为协作者 然后协作者就拥有了对该仓库的提交等权限了 那这个时候，一定团队成员，有一定风险 所以这个时候会做一些口头约定：Code Review 以及代码合并 你不要去合并，由项目管理者去选择合并 提交之前，最好把你的领导叫过来，我要合往master分支提交代码，它去Code Review 大公司里面，有一个职业就是 Code Reviewer 人工审查 Pull Request 先基于团队项目的git仓库 fork 到你的账户下 组长创建一个仓库 在 master 中初始化一些项目的基本结构 完事儿了，让小组成员去 fork 组长创建的仓库 fork 到自己的账户下 然后通过自己账户下 fork 过来的仓库 clone 到本地 然后基于 master 创建一个特性分支 基于特性分支开发（开发完毕不要自己去合并到 master） 把该分支 push 到 Github 上 然后在 Github 上通过 Pull Request 的形式发起一个合并请求 一般都是将你开发的特性分支合并到对方仓库的 master 分支上 组长会收到一个 Pull Request 合并请求 code review 例如代码不合格，就可以发起 review，可以以社交化的形式进行协作 直到没有问题之后，合并到 master 分支上 这个只是合并到你组长的账户下的仓库的 master 上了 对于你的账户下的 master 还是原来的 这个时候，需要和你 fork 的仓库上的 master 进行一次同步 通过 git remote add 名字 地址 把团队仓库地址添加到你的本地 通过 git pull 名字 分支名称 将指定远端仓库的指定分支拉取到本地 其他12# 生成一个可供发布的压缩包$ git archive Git 其它工具 和 IDE 的结合 图形化工具 和 Git 相关的产品 GItlab 码云 coding 资源推荐 Github入门与实践 git学习资料整理 如何高效利用GitHub]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[body-parser 部分API]]></title>
      <url>%2F2016%2F12%2F23%2Fbody-parser%E6%8F%92%E4%BB%B6%20API%2F</url>
      <content type="text"><![CDATA[node安装 1$ npm install body-parser API 1var bodyParser =require(&apos;body-parser&apos;) 可以通过body-parser 对象创建中间件，当接收到客户端请求时所有的中间件都会给req.body 添加属性，请求体为空，则解析为空{} （或者出现错误）。 bodyParser.json(options)中间件只会解析 json ，允许请求提任意Unicode编码支持 gzip 和 deflate 编码。 options一个对象，有以下属性 inflate默认为false，true-&gt;压缩的请求体会被解压，false-&gt;压缩的请求提不被解压。 limit控制请求体最大大小，默认为100kb，当为数字时会转换为bytes，当为字符串时，value值会通过 bytes库 转换为字节大小。 reviver此选项会通过JSON.parse直接传给其第二个参数。 strict默认为true，当为true时只接受数组和对象，当为false时会接受任何JSON.parse 能接受的。 typetype 选项用来决定中间件要解析媒体类型。选项可以是一个函数或者是字符串。当为字符串时，可以直接通过type-is 库直接传递给选项，字符串也可以为一个扩展名（例如json）、mime 类型（application/json、/ 、*/json）。当为函数时：默认为application/json。 verifyverify选项，若缺失则为一个函数function（req,res,buf,encoding）,buf为一个Buffer。 bodyParse.raw(option)将请求体内容作为Buffer来处理，并返回。支持gzip deflate 压缩。 inflate limit type verify bodyParser.text(option)将请求提内容作为字符串来处理，并返回。支持gzip deflate 压缩。 defaultCharset若请求头未设置Content-Type则默认为utf8 inflate type verify bodyParser.urlencoded(option)中间件只解析urlencoded 请求体，并返回，只支持UTF-8编号文本，支持gzip deflate 压缩。 extend ture-&gt;使用queryString库（默认） false-&gt;使用qs库。 limit parameterlimit指定parameters最长长度，默认1000 type verify]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Formidable插件 API]]></title>
      <url>%2F2016%2F12%2F23%2FFormidable%E6%8F%92%E4%BB%B6%20API%2F</url>
      <content type="text"><![CDATA[创建Formidable.IncomingForm对象 1 var form = new formidable.IncomingForm() form.encoding = ‘utf-8’ 设置表单域的编码 form.uploadDir = “/my/dir”; 设置上传文件存放的文件夹，默认为系统的临时文件夹，可以使用fs.rename(先前的路径文件,改变后的路径文件)来改变上传文件的存放位置和文件名,当文件的目录一致的时候是修改的文件名字,当文件的目录的不一致的时候是移动文件 form.keepExtensions = false; 设置该属性为true可以使得上传的文件保持原来的文件的扩展名。 form.type 只读，根据请求的类型，取值’multipart’ or ‘urlencoded’ form.maxFieldsSize = 2 1024 1024; 限制所有存储表单字段域的大小（除去file字段），如果超出，则会触发error事件，默认为2M form.maxFields = 1000 设置可以转换多少查询字符串，默认为1000 form.hash = false; 设置上传文件的检验码，可以有两个取值’sha1’ or ‘md5’. form.multiples = false; 开启该功能，当调用form.parse()方法时，回调函数的files参数将会是一个file数组，数组每一个成员是一个File对象，此功能需要 html5中multiple特性支持。 form.bytesReceived 返回服务器已经接收到当前表单数据多少字节 form.bytesExpected 返回将要接收到当前表单所有数据的大小 form.parse(request, [callback]) 该方法会转换请求中所包含的表单数据，callback会包含所有字段域和文件信息，如： 123 form.parse(req, function(err, fields, files) &#123; // ... &#125;); form.onPart(part); 你可以重载处理multipart流的方法，这样做的话会禁止field和file事件的发生，你将不得不自己处理这些事情，如： 123456789101112 form.onPart = function(part) &#123; part.addListener(&apos;data&apos;, function() &#123; // ... &#125;); &#125;//如果你只想让formdable处理一部分事情，你可以这样做: form.onPart = function(part) &#123; if (!part.filename) &#123; // 让formidable处理所有非文件部分 form.handlePart(part); &#125; &#125; formidable.File对象 - file.size = 0 上传文件的大小，如果文件正在上传，表示已上传部分的大小 - file.path = null 上传文件的路径。如果不想让formidable产生一个临时文件夹，可以在fileBegain事件中修改路径 - file.name = null 上传文件的名字 - file.type = null 上传文件的mime类型 - file.lastModifiedDate = null 时间对象，上传文件最近一次被修改的时间 - file.hash = null 返回文件的hash值 - 可以使用JSON.stringify(file.toJSON())来格式化输出文件的信息无论是否上传图片,formidable都会默认传一个文件上去,当没有选择图片的时候,该文件的size为0 form.on(‘progress’, function(bytesReceived, bytesExpected) {});当有数据块被处理之后会触发该事件，对于创建进度条非常有用。 form.on(‘field’, function(name, value) {});每当一个字段/值对已经收到时会触发该事件 form.on(‘fileBegin’, function(name, file) {});在post流中检测到任意一个新的文件便会触发该事件 form.on(‘file’, function(name, file) {});每当有一对字段/文件已经接收到，便会触发该事件 form.on(‘error’, function(err) {});当上传流中出现错误便会触发该事件，当出现错误时，若想要继续触发request的data事件，则必须手动调用request.resume()方法 form.on(‘aborted’, function() {});当用户中止请求时会触发该事件，socket中的timeout和close事件也会触发该事件，当该事件触发之后，error事件也会触发 form.on(‘end’, function() {});当所有的请求已经接收到，并且所有的文件都已上传到服务器中，该事件会触发。此时可以发送请求到客户端。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas学习笔记 04]]></title>
      <url>%2F2016%2F11%2F21%2Fcanvas%2004%2F</url>
      <content type="text"><![CDATA[canvas 04 requestAnimationFrame:这个函数实际上是setTimeout的另类版本,使用方式和setTimeout几乎一致区别在于setTimeout可以自由指定回调的执行时机,而requestAnimationFrame不有指定执行时机,当浏览器重绘页面之前会尝试执行传入requestAnimationFrame的回调函数,也就是所传入requestAnimationFrame的时机与页面重绘几乎同时,这个函数主要是为了开发流畅的动画优点:requestAnimationFrame调用的时候帧数更稳定,比setTimeout更好,流畅.缺点:有兼容性问题.IE8 12345678910111213141516171819202122232425262728293031/** * requestAnimationFrame兼容性扩展，两方面工作： * 1、把各浏览器前缀进行统一 * 2、在浏览器没有requestAnimationFrame方法时将其指向setTimeout方法 * */ (function() &#123; var lastTime = 0; var vendors = [&quot;webkit&quot;, &quot;moz&quot;]; for (var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x] + &quot;RequestAnimationFrame&quot;]; // Webkit中此取消方法的名字变了 window.cancelAnimationFrame = window[vendors[x] + &quot;CancelAnimationFrame&quot;] || window[vendors[x] + &quot;CancelRequestAnimationFrame&quot;]; &#125; if (!window.requestAnimationFrame) &#123; window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16.7 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; &#125; if (!window.cancelAnimationFrame) &#123; window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;; &#125; &#125;()); 停止动画:可以考虑使用布尔类型变量进行判断,类似于递归的条件判断 ctx.arcTo(控制点1的x轴坐标,控制点1的y轴坐标,控制点2的x轴坐标,控制点2的y轴坐标,半径)注意:arcTo绘制弧,不需要圆心坐标.不需要起始位置和结束位置示例: ctx.moveTo(10,10);ctx.arcTo(210,10,210,100,200);ctx.stroke(); toDataURL如果导出的图片格式为jpeg,可以指定第二个参数,设置图片的压缩率cvs.toDataURL(“image/jpeg”,0.5);png是高保真图片格式,无法设置压缩率用法:传给图片的src即可使用场景:一个网站如果小图片不多,可以考虑使用.如果小图片比较多,可以优先使用精灵图,如果大图多,延迟加载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas学习笔记 03]]></title>
      <url>%2F2016%2F11%2F20%2Fcanvas%2003%2F</url>
      <content type="text"><![CDATA[canvas 03 ctx.translate(x轴平移多少,y轴平移多少)注意:平移的是画布坐标系,平移后不会影响到之前绘画的内容.平移可以累加 ctx.rotate(旋转的弧度)注意:旋转的是画布坐标系,旋转基点是画布的(0,0)点.旋转后不会影响到之前绘画的内容.旋转可以累加,参数正数的时候是顺时针旋转 ctx.scale(x轴缩放多少倍,y轴缩放多少倍)注意:缩放的的是画布坐标系,缩放后不会影响到之前绘画的内容.缩放可以累加 状态保存与回滚 状态:是指绘制上下文所有的属性值,即ctx下的全部属性 状态保存 ctx.save():就是把ctx对象当前所有的属性值进 行备份(复制一份存储起来).++状态保存与路径无关,save不会保存页面的路径++ 状态回滚 ctx.restore():就是把之前的备份的状态取出来,作为 当前状态使用多次备份与回滚:多次取的时候,是按照保存的倒序来取,也就是第一次取的是最后一次保存的,以此类推. 路径点判断ctx.isPointInPath(要判断的点x坐标,要判断的点y坐标),返回的是true/false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas学习笔记 02]]></title>
      <url>%2F2016%2F11%2F18%2Fcanvas%2002%2F</url>
      <content type="text"><![CDATA[canvas 02 绘制文字 描边文字ctx.strokeText(“要绘制的文字”,x轴坐标,y轴坐标,限制文字绘制时占用的最大长度(可选)) 填充文字ctx.fillText(“要绘制的文字”,x轴坐标,y轴坐标,限制文字绘制时占用的最大长度(可选)) 设置文字样式ctx.font=”900 20px 微软雅黑”和CSS语法一样,必须加单位,字体也必须写才能生效 设置文字水平对齐方式ctx.textAlign=”left/start”||”center”||”right/end”参考点为设置文字的起始点,左对齐就是从右向左靠拢,会显示在参考点的右边;右对齐就是从左往右靠拢,会显示在参考点的左边 设置文字水平对齐方式ctx.textBaseline=”top”||”middle”||”bottom”||”alphabetic”||”hanging||”ideographic”,默认为alphabetic.同样的,参考点为设置文字的起始点,top就是把参考点放在上面,bottom就是把参考点放在下面,因此在使用的时候和平时的感觉不太一样,bottom是往下移动,top是往上移动 预测量文字ctx.measureText(“被测量的文字”)预测一段文字,按照当前文字的字体的大小,绘制时要占用多宽多高,现在浏览器只能测试文字所占用的宽度,返回值是一个对象,目前这个对象只有width属性 绘制扇形 利用的是绘制弧线的时候,会从原先的路径连接到弧的起点,然后用closePath闭合,形成扇形 步骤: ctx.moveTo(圆心x,y) ctx.arc()以圆心为基准点 ctx.closePath(); ctx.stroke(); 如果是直接填充fill(),canvas会自动closePath() 绘制饼图 function(ctx,data,x,y,r){} ctx 上下文 data 数据 x,y 圆心坐标 半径 创建img元素的3种方式 html new Image() document.createElement(“img”) 绘制图像 ctx.drawImage(要绘制的图像资源,图像绘制到画布的X轴坐标,图像绘制到画布的y轴坐标)在绘制过程中,如果不加任何条件,是异步加载,在下载图片资源的同时就会开始进行绘制,所以会导致无法正常显示,建议用事件监听来控制 img.onload=funciton(){ctx.drawImage(img,x,y)} ctx.drawImage(要绘制的图像资源,图像绘制到画布的X轴坐标,图像绘制到画布的y轴坐标,指定图像绘制的宽度,指定图像绘制的高度) ctx.drawImage(要绘制的图像资源,裁剪的起始x轴坐标,裁剪的起始y轴坐标,裁剪多宽,裁剪多高,x轴坐标,y轴坐标,指定图像绘制的宽度,指定图像绘制的高度)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas学习笔记 01]]></title>
      <url>%2F2016%2F11%2F17%2Fcanvas%2001%2F</url>
      <content type="text"><![CDATA[canvas 01 canvas作用: 游戏 数据可视化(图表) 环境的含义:一个东西赖以生存的绘图环境:绘制图形所需的东西路径是一个图形的轮廓,是对将来要绘制图形的一个规划让路径最终生效需要描边canvas通过js来绘制 需要获取一个绘图环境 通过canvasDOM元素提供的一个方法getContextcvx=document.querySelector(“canvas”);ctx=cvs.getContext(“2d”||”wgbgl”)(在这里一般用2d) 绘图图形: 先移动钢笔到指定的位置(图形的起始位置)ctx.moveTo(二维坐标); 画图形的路径ctx.lineTo(二维坐标); 描边ctx.stroke(不用填); 动态设置画布大小(默认300*150) canvasDOM对象有width和height属性 canvas绘制的是位图(像素图),默认单位px,设置的时候不用加单位 动态设置大小会清除画布的内容 不要设置canvas样式中的宽高,因为会拉伸 基于状态(属性值) 根据属性的变化,表现出来的结果不一样 描边色 ctx.strokeStyle=””支持所有颜色表示方式,修改描边色之后,一些和描边相关的方法,再次调用时候相关方法都会受影响(多次描边会叠加) 清除路径(开辟新路径) ctx.beginPath(不用填) 开辟新的路径,避免重复描边 路径是看不见的,描边过的清除路径并不会影响已经描边的情况 线宽 ctx.lineWidth=(不要单位) 闭合路径 ctx.closePath(不用填); 最后一条路径不用写 设置填充 ctx.fill();调用的方法 ctx.fillStyle=””;设置填充样式 填充和描边的顺序: 先填充后描边可以显示出真正的描边宽度 先描边后填充,填充部分会占用一般的描边宽度,因为描边的时候是沿着边框,里外各一半宽度 非零环绕原型: 作用:用来判断路径围起来的区域是否在路径内 原理: 在路径包含的区域内随便找一点向外发射一条线,让这条线贯穿所有围绕该点的路径 开启一个计数器,初始值为0 遇到顺时针围绕点的路径,数+1 逆时针,数-1 最终结果不是0,可以认为这块区域在路径包含之内 清除整个画布ctx.clearRect(起点坐标x,起点坐标y,宽,高) 画矩形路径ctx.rect(起始x轴,起始y轴,宽(正负代表方向),高(正负代表方向)) 绘制描边矩形(不产生路径)ctx.strokeRect(起始x轴,起始y轴,宽,高),该方法不产生路径,所以fill方法无效 绘制填充矩形(不产生路径)ctx.fillRect(起始x轴,起始y轴,宽,高) 线帽样式ctx.lineCap=”butt”||”round”||”square”.默认值butt round 圆头,两端也加长了线宽的一半 square 是两端各加长线宽的一半 交点样式(两条线交点处的样式)ctx.lineJoin=”miter”(尖头)||”round”(圆头)||”bevel”(斜面).默认为mitermiterlimit(尖头最大长度,默认10) 虚线绘制ctx.setLineDash([5,5])(实线长度,虚线长度). 参数可以写很多,都是实线.虚线的顺序 参数可以写奇数个,实线虚线交替,轮到谁就是谁,不再固定指谁是实线长度谁是虚线长度 ctx.getLineDash,获取虚线设置 关于路径起点的设置 正常情况通过moveTo来设置 如果之前没有任何路径和路径的起点,那么第一个lineTo相当于moveTo 画弧路径ctx.arc(圆心x轴坐标,圆心y轴坐标,半径,弧的起始位置,弧的结束位置,是否逆时针画(可选,默认顺时针,false));传的是弧度,可用一个函数来转换为度数Math.PI/180*度数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[requireJS作用和用法]]></title>
      <url>%2F2016%2F08%2F05%2FrequireJS%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[requireJS的需求 需求: 在一个网页有大量的js需要加载的时候,传统方式就是用大量的script标签依次加载. 1234567//举个栗子&lt;script src="1.js"&gt;&lt;/script&gt;&lt;script src="2.js"&gt;&lt;/script&gt;&lt;script src="3.js"&gt;&lt;/script&gt;&lt;script src="4.js"&gt;&lt;/script&gt;&lt;script src="5.js"&gt;&lt;/script&gt;&lt;script src="6.js"&gt;&lt;/script&gt; 缺点 首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长 其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难 requireJS作用 实现js文件的异步加载，避免网页失去响应 管理模块之间的依赖性，便于代码的编写和维护 使用requireJS 加载requireJS 1&lt;script src="js/require.js"&gt;&lt;/script&gt; 加载这个文件，也可能造成网页失去响应 解决办法: 一个是把它放在网页底部加载 见下面代码 1 &lt;script src="js/require.js" defer async="true" &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 加载主模块data-main 指定网页程序的主模块。这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 1 &lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 主模块类似于入口函数,也就是所有代码必须先经过它 main.js的写法 如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码 123//main.jsalert('加载成功')//这种情况不需要requireJS 一般来说,主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。 1234// main.jsrequire(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC)&#123;// some code here&#125;); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’,’moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 12345//假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123;// some code here&#125;);//require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。 模块加载 假如主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。 使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部(或者通过script标签先后加载require.js和require.config.js).参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。 模块与main.js在同一个目录下的加载方式 1234567require.config(&#123; paths: &#123; "jquery": "jquery.min", "underscore": "underscore.min", "backbone": "backbone.min" &#125;&#125;); 模块在其他目录 1234567891011121314151617//比如js/lib目录，main.js在js目录下,则有两种写法。一种是逐一指定路径require.config(&#123; paths: &#123; "jquery": "lib/jquery.min", "underscore": "lib/underscore.min", "backbone": "lib/backbone.min" &#125;&#125;);//另一种则是直接改变基目录（baseUrl）require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": "jquery.min", "underscore": "underscore.min", "backbone": "backbone.min" &#125;&#125;); 模块在另一台主机上 123456//可以直接指定它的网址，比如：require.config(&#123; paths: &#123; "jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min" &#125;&#125;); 注意:如果加载模块的标识名称中含有.js则相对于当前页面的url路径去查找,一般来说,最好paths和require的时候都不要加.js 有时候你想避开”baseUrl + paths”的解析过程，而是直接指定加载某一个目录下的脚本。此时可以这样做：如果一个module ID符合下述规则之一，其ID解析会避开常规的”baseUrl + paths”配置，而是直接将其加载为一个相对于当前HTML文档的脚本： 以 “.js” 结束. 以 “/“ 开始. 包含 URL 协议, 如 “http:” or “https:”. AMD模块的写法 require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写. 具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 不依赖其他的模块 123456789// math.jsdefine(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;;&#125;); 12345//加载模块// main.jsrequire(['math'], function (math)&#123; alert(math.add(1,1));&#125;); 依赖其他模块的模块加载 123456789101112131415161718192021//define()函数的第一个参数，必须是一个数组，指明该模块的依赖性define(['myLib'], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;;&#125;);//当require()函数加载上面这个模块的时候，就会先加载myLib.js文件//或者也可以这样写define(function(myLib)&#123; var $ = require('myLib') function foo()&#123; $.doSomething(); &#125; return &#123; foo : foo &#125;;&#125;); 加载非规范的模块 require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合 加载方式:在用require()加载之前，要先用require.config()方法，定义它们的一些特征 1234567891011121314151617require.config(&#123; shim: &#123; 'underscore':&#123; exports: '_' &#125;, 'backbone': &#123; deps: ['underscore', 'jquery'], exports: 'Backbone' &#125; &#125;&#125;);// 对于所有有依赖的插件来说：// 1. 先在 paths 中配置该插件的标识及路径// 2. 在 shim 中，手动给该插件声明依赖项// 3. 使用的时候，只需要通过 paths 中配置的插件名称加载就可以了，它会自动去找依赖项// 如果有对外暴露的接口，则直接使用就可以了// 如果是类似于 jQuery 插件的东西，就直接加载就可以了，没有暴露的接口对象 require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义 exports值（输出的变量名），表明这个模块外部调用时的名称,针对那些老旧的，没有按照AMD规范声明的代码，把他们暴露在window下的对象名，映射到key上去。 deps数组，表明该模块的依赖性。 建议的写法 12//先用script标签加载require.js data-main类似于入口函数会紧跟着加载&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; 123456789101112131415161718192021//data-main里面的写法require.config(&#123;//设置基础路径,以后require的路径前面都会加上baseUrl的内容 baseUrl: '/public', paths: &#123; underscore: '/node_modules/underscore/underscore', jQuery.lazyload: '/node_modules/jQuery.lazyload/jQuery.lazyload', jquery: '/node_modules/jquery/dist/jquery', &#125;, shim: &#123; //设置依赖项和对外暴露的符号 //如果有对外暴露的接口，则直接使用就可以了,不需要export的时候建议不写 jQuery.lazyload:&#123; deps:['jquery'], &#125; &#125;&#125;)//需要require的时候,去找paths里面定义的名字,建议形参用该模块对外暴露的id去接收,参照习惯比较方便,当然你用@去接收jQuery在回调函数里面也需要@()来获取元素require(['jquery', 'underscore', 'jQuery.lazyload'], function ($, _, lazy)&#123;// some code here&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器同源策略和跨域问题]]></title>
      <url>%2F2016%2F06%2F25%2F%E8%B7%A8%E5%9F%9F%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[同源策略所谓同源策略，指的是浏览器对不同源的脚本或者文本的访问方式进行的限制。比如源a的js不能读取或设置引入的源b的元素属性。 同源:URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。 一个网站的网址组成包括协议名，子域名，主域名，端口号。比如https://www.github.com/80，其中https是协议名，www是子域名，github是主域名，端口号是80，当在在页面中从一个url请求数据时，如果这个url的协议名、子域名、主域名、端口号任意一个有一个不同，就会产生跨域问题。即使是在 http://localhost:80/ 页面请求 http://127.0.0.1:80/ 也会有跨域问题（因为域名不一样） PS：浏览器中的file://域拥有的权限很高，WebKit可以读取磁盘上的文件，IE可以执行CMD 特别注意两点：一.如果是协议和端口造成的跨域问题“前台”是无能为力的二.在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 在浏览器中，&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。（跨域限制是浏览器行为，不是服务器行为) 另外同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、image等仍然认为属于同源。 跨域的方法 jsonp - 动态创建script标签实现跨域浏览器的script、img、iframe标签是不受同源策略限制的 ，所以通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的callback函数，并把把我们需要的json数据作为参数传入。在服务器端，当req.params参数中带有callback属性时，则把数据作为callback的参数执行，并拼接成一个字符串后返回。创建一个新的script标签，并插入DOM中，浏览器会像载入页面本身的script标签一样载入和运行插入标签的源文件。新script标签的源文件包含了一个页面本身已存在的一个JavaScript函数的调用，当执行这个源文件时，也会执行已存在的函数，这一过程定义了一个回调函数的方法。实际的jsonp接口中，会让你传一个函数名过去，然后返回的数据中回调函数名就是你传的函数名，回调函数的参数则是封装的json格式。jQuery中的jsonp实现原理基本就是这样 例子:第一个是http://www.foo.com/jsonp.html，通过动态创建script标签加载了http://www.bar.com/js/outer.js文件.然后outer.js文件返回的内容正好是一个函数调用，就会执行这个函数.如此，实现了数据传递和回调过程 1234567891011121314151617# jsonp.html&lt;script type="text/javascript"&gt;function callback(data) &#123; alert(data.message);&#125;function addScriptTag(src)&#123;var script = document.createElement('script'); script.src = src; document.body.appendChild(script);&#125;window.onload = function()&#123; addScriptTag("http://www.foo.com/js/outer.js");&#125;&lt;/script&gt;# outer.jscallback(&#123;message:"success"&#125;); 判断script节点加载完毕：IE只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。 123456js.onload = js.onreadystatechange = function() &#123; if (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') &#123; // callback在此处执行 js.onload = js.onreadystatechange = null; &#125; &#125;; 优点：兼容性好，在很古老的浏览器中也可以用，简单易用，支持浏览器与服务器双向通信。 缺点 只支持GET请求(因为基于script)且只支持跨域HTTP请求这种情况（不支持HTTPS) 安全问题(请求代码中可能存在安全隐患) 要确定jsonp请求是否失败并不容易 CORS跨域 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10 CORS请求分成两类：简单请求（simple request）和非简单请求 简单请求: 12345678910（1) 请求方法是以下三种方法之一： HEAD GET POST（2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段. Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。也解决了jsonp里面post不能跨域的问题 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 更多详情见阮一峰博客 例子: 启动nodejs web应用的app.js 1234567var express = require("express"); var http = require("http"); var app = express(); var router = express.Router(); var testRouter = require('./routes/test/test'); app.use('/test', testRouter); http.createServer(app).listen(3000); 处理具体api的控制器 test.js 1234567891011121314151617181920212223var express = require('express'); var router = express.Router(); /* GET home page. */ router.get('/', function(req, res, next) &#123; res.render('index', &#123; name: 'Express 路由1' &#125;); &#125;); /* GET home page. */ router.get('/cors', function(req, res, next) &#123; res.render('test/index', &#123; name: 'Express 路由1' &#125;); &#125;); /* GET home page. */ router.get('/getData', function(req, res, next) &#123; //设置允许跨域请求 var reqOrigin = req.header("origin"); if(reqOrigin !=undefined &amp;&amp; reqOrigin.indexOf("http://localhost:3000") &gt; -1)&#123; //设置允许 http://localhost:3000 这个域响应 res.header("Access-Control-Allow-Origin", "http://localhost:3000"); res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS"); res.header("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With"); &#125; res.json(200, &#123;name:"张三1",age:40&#125;); &#125;); module.exports = router; 模板页面，发送ajax跨域请求 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;script src="../public/js/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="../public/js/hb_common.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="../public/css/bootstrap.min.css"&gt; &lt;link rel="stylesheet" href="../public/css/hb_wap.css"&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body &gt; &lt;button class="btn btn-primary" id="btn" onclick="corsGetData()"&gt;cors跨域获取数据&lt;/button&gt; &lt;br&gt; &lt;button class="btn btn-primary" id="btn4" onclick="getData()"&gt;不跨域获取数据&lt;/button&gt; &lt;br&gt; &lt;/body&gt; &lt;script&gt; function getData()&#123; $.ajax(&#123; url: "http://localhost:3000/test/getData", type:"GET", cache: false, success: function(html)&#123; alert(html); $("#results").append(html); &#125; &#125;) &#125; function corsGetData()&#123; $.ajax(&#123; url: "http://www.huangbiao.com:3000/test/getData", type:"GET", cache: false, success: function(html)&#123; alert(html); $("#results").append(html); &#125; &#125;) &#125; &lt;/script&gt; &lt;/html&gt; 特点: CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。 JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 代理跨域nodeJS实现代理原理:我们在127.0.0.1:5000/index.html下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如127.0.0.1:5000/api/products,然后这个代理发送HTTP请求访问127.0.0.1:3000/api/products，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略限制），客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性 页面:向http://127.0.0.1:5000/api/products发起ajax请求 123456789//html页面部分js$.ajax(&#123; url:'/api/product', type:'get', dataType:'json', success:function(data)&#123; console.log(data) &#125;&#125;) 本地服务器: 1234567app.get('/', (req, res, next) =&gt; &#123; res.render('index.html')&#125;)app.listen(5000, () =&gt; &#123; console.log('running at port 5000...')&#125;) 接口代理:本地服务器在接受请求之后,将请求转发给http://127.0.0.1:3000/api/products本地服务器: 1234567891011app.get('/api/products', (req, res, next) =&gt; &#123; http.get('http://127.0.0.1:3000/api/products', proxyRes =&gt; &#123; let data = '' proxyRes.on('data', chunk =&gt; &#123; data += chunk &#125;) proxyRes.on('end', () =&gt; &#123; res.send(data) &#125;) &#125;)&#125;) api接口服务器:接收到请求之后,相应一个json格式的数据需要跨域的服务器: 12345678app.get('/api/products', (req, res, next) =&gt; &#123; res.send(&#123; success: true, ret: &#123; list: products &#125; &#125;)&#125;) 代理跨域常用的中间件http-proxy-middleware 作用：将当前网站所有的 /api 开头的请求都代理到 http://127.0.0.1:3000，代理是没有跨域限制的 你请求的时候，还是直接请求自己网站的 /api/** proxy 将你的请求代理到 http://127.0.0.1:3000 ，请求转发 proxy 将接收到的数据原封不动的响应给你的请求 1234//写了这个,上述接口代理,就是本地服务器的一段代码简化为这个//该中间件自动帮你处理//注意:除了端口的区别,其他必须一致,比如/api/productsapp.use(&apos;/api&apos;, proxy(&#123;target: &apos;http://127.0.0.1:3000&apos;, changeOrigin: true&#125;))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[闭包及相关概念以及使用]]></title>
      <url>%2F2016%2F05%2F17%2F%E9%97%AD%E5%8C%85%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[闭包的概念 闭包：指有权访问另一个函数作用域中的变量的函数。闭包的本质是将函数内部和函数外部连接起来的一座桥梁.在JavaScript中，内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后 如何创建闭包 12345678910function outer()&#123; var a=1; function inner()&#123; a++; alert(a); &#125; return inner;&#125;var f1=outer();//创建了一个闭包，f1能访问outer函数中的变量f1();//弹出2. 这段代码的特点在于： 函数inner嵌套在函数outer内部 函数outer返回函数inner，并将值赋给了f1 123456789101112131415161718192021// 实现累加：方式1var a = 0;var add = function()&#123; a++; console.log(a)&#125;add();add();//方式2 ：闭包var add = (function()&#123; var a = 0; return function()&#123; a++; console.log(a); &#125;&#125;)();console.log(a); //undefinedadd();add();//方式2的优点：减少全局变量，将变量私有化 闭包与变量的关系 闭包只能取得包含函数中任何变量的最后一个值。 1234567891011121314151617181920212223242526272829function f1() &#123; var res = new Array(); for(var i=0;i&lt;10;i++)&#123; res[i] = function() &#123; alert(i); &#125;; &#125; return res;&#125;var f2 = f1();var f2 = f1();f2[0]();//alert 10//并不会返回一次弹出0-9的函数数组，而是弹出10个10的函数数组,因为res中每个函数的作用域中都保存着f1()的活动对象，引用的是同一个变量i，当f1()返回后i的值为10解决方法：function f1() &#123; var res = new Array(); for(var i=0;i&lt;10;i++)&#123; res[i] = (function(num) &#123; return function ()&#123; alert(num); &#125; &#125;)(i);//函数参数按值传递 &#125; return res;&#125;var f2 = f1();var f2 = f1();f2[0]();//alert 0 内存泄露及解决方案 垃圾回收机制说到内存管理，自然离不开JS中的垃圾回收机制，有两种策略来实现垃圾回收：标记清除 和 引用计数； 标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。 2008年为止，IE，Firefox，opera，chrome，Safari的javascript都用使用了该方式； 引用计数：跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个值的引用次数就是1，如果这个值再被赋值给另一个变量，则引用次数加1。相反，如果一个变量脱离了该值的引用，则该值引用次数减1，当次数为0时，就会等待垃圾收集器的回收。 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。早期的IE版本里（ie4-ie6）采用是计数的垃圾回收机制，闭包导致内存泄露的一个原因就是这个算法的一个缺陷。 123456window.onload = function()&#123; var ele = document.getElementById(&quot;id&quot;); ele.onclick = function()&#123; alert(ele.id); &#125;&#125; 这段代码为什么会造成内存泄露？ 123ele.onclick = function()&#123; alert(ele.id); &#125; 执行这段代码的时候，将匿名函数对象赋值给ele的onclick属性；然后匿名函数内部又引用了ele对象，存在循环引用，所以不能被回收。 解决方法： 12345678window.onload = function()&#123; var ele = document.getElementById(&quot;id&quot;); var id = ele.id; //解除循环引用 ele.onclick = function()&#123; alert(id); &#125; ele = null; // 将闭包引用的外部函数中活动对象清除&#125; 总结闭包的优缺点 优点： 当需要一个变量常驻内存时，闭包可以实现一个变量常驻内存 (如果多了就占用内存了) 避免全局变量的污染 私有化变量 实现封装性 缺点: 因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存 常驻内存，增大内存的开销，使用不当就会造成内存泄漏。 闭包的一些应用 计数器 1234567891011121314151617181920212223242526 function makeCounter() &#123; var count = 0; return &#123; update: function() &#123; count++; &#125;, get: function() &#123; return count; &#125; &#125;;&#125;var personCounter = makeCounter();// var count = 0;function Person() &#123; // count++; personCounter.update();&#125;new Person;new Person;new Person;new Person;new Person;new Person;new Person;// console.log(count);console.log(personCounter.get()); // 7 沙箱模式–匿名自调用函数。很多的框架都使用了沙箱模式与外界隔离。即可以分割作用域,内部代码自执行。在实际开发中，可以考虑将全局对象当做实参传入沙箱内部的变量，以提高js性能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //沙箱:模块化,沙箱是一个隔离的环境,最大的好处就是避免全局变量的污染.var model = (function () &#123;//一个匿名的立即执行函数 var price = 900;//这是一个model局部的变量,外界无法访问,无法修改 //有效的保障了属性的安全性 return &#123; pay: function (money) &#123; if (money &lt; price) &#123; console.log("您的消费不够,请继继续消费"); &#125; else &#123; console.log("恭喜成为VIP"); &#125; &#125; &#125;&#125;)();console.log(model.pay(800));//"消费不够.." undefined model.pay(1000);//"VIP..."//千万注意不用打印,pay函数本身就有输出,如果在console.log中//会输出函数的返回值.//在面向对象中使用沙箱//应用场景:在页面初始化的时候要用到f1,f2,f3三个函数//这三个函数不想让外界访问,需要把这单个方法声明成为构造函数//内部私有的变量var songManger = (function()&#123; function f1()&#123; console.log("函数f1的方法"); &#125; function f2()&#123; console.log("函数f2的方法"); &#125; function f3()&#123; console.log("函数f4的方法"); &#125; function SongManger()&#123;//声明一个构造函数 &#125; SongManger.prototype=&#123;//在原型对象上扩展方法 init:function()&#123; f1(); f2(); f3(); &#125; &#125;; // return SongManger;//注意这个返回的是构造函数,使用之前需要先实例化一下 return new SongManger;//把构造函数返回,实例化一下,这样外边就不需要实例化了&#125;)();songManger.init();// 缓存 – (例子:优化fib递归调用性能) 12345678910111213141516171819202122232425262728// 解决方案: 将每一次计算的结果，缓存起来。// 1. 在求值时，首先在缓存里拿。// 2. 如果有值，就直接返回。// 3. 如果没有值，就重新计算。将结算结果缓存并返回。 // 1. 确定缓存的数据结构 []// 2. // 获取求fib数列第n项值的闭包函数var fib = function () &#123; // 缓存计算结果 var cache = []; // 返回求fib数列的闭包函数 return function( n ) &#123; // 从缓存获取数据 var val = cache[n]; // 如果有值, 直接返回值 if(val) return val; // 如果没有值 else &#123; // 如果n的值 为1 或者 2,值为 1. if(n === 1 || n === 2) val = 1; // 如果n的值 大于 2, 递归重新求值 else if(n &gt; 2) val = arguments.callee(n - 1) + arguments.callee(n - 2); // 将重新计算的值,缓存起来并返回 return cache[n] = val; &#125; &#125;;&#125;(); 实现面向对象的封装 1234567891011121314151617181920 function Person(name, age) &#123; return &#123; getAge: function() &#123; return age; &#125;, getName: function() &#123; return name &#125;, setAge: function(val) &#123; age = val; &#125; &#125;;&#125;var zs = new Person('张三', 18);console.log(zs.name); // undefinedconsole.log(zs.getName());console.log(zs.age);// undefinedconsole.log(zs.getAge());zs.setAge(68);console.log(zs.getAge()); 科里化/参数复用：将一个拥有多个参数的函数 转化成 一个单一参数函数的形式。 1234567891011121314151617181920212223242526272829//科里化的本质可以理解为把一个函数作为另一个函数的参数//而且被作为参数的函数,多为闭包结构,因为需要返回一个参数作为新的参数//如果为闭包结构,那么在外层函数传入此函数作为参数的时候,多半在调用参数的时候需要再传入参数window.onload=function()&#123; function selectLi(fn)&#123; //获取所有指定元素 var lis=document.querySelectorAll("#nav li"); //遍历获取的li元素,添加点击事件 for(var i=0;i&lt;lis.length;i++)&#123; lis[i].addEventListener("click",function()&#123; switch (this.getAttribute("data-name"))&#123; case "find" : fn("这是发现音乐");break; case "mine" : fn("这是我的音乐");break; case "friend" : fn("这是我的朋友");break; &#125; &#125;) &#125; &#125; //获取指定元素修改其中的文本 function changeText()&#123; var content=document.querySelector("#content"); return function(text)&#123; content.innerHTML=text; &#125; &#125; //将一个函数传入另一个函数作为参数,可以认为是科里化最大的特征 //如果有类似的需求,以后可以直接将函数传入,更改其中传入的参数即可,以达到参数复用的地步 selectLi(changeText());&#125; 延迟计算/执行就是通过闭包,先保存数据,最后根据需求再进行计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 // 需求:统计某公司销售人员周售楼总数(周平均) /*var weelySales = 0; function dailySales(val) &#123; weelySales += val; &#125; dailySales(1); dailySales(2); dailySales(3); dailySales(4); dailySales(5); dailySales(6); dailySales(7); console.log(weelySales); // 28*//** * [curryingSales 创建可以获取和保存数据闭包函数] * @param &#123;Function&#125; fn [fn函数决定是获取周总数（平均数）] * @return &#123;[type]&#125; [闭包函数] */ function curryingSales(fn) &#123; var dailySales = []; return function(val) &#123; // 根据fn，获取售楼数。 if(val == undefined)&#123; //假如不传参数,代表获取,具体获取什么参数由fn决定 //这时只需要将dailySales作为参数传入fn即可 //这里必须要有return,否则curryingSales无法得到返回值,因为在这里需求是获取数据,如果没有返回值就无法获取数据 return fn.apply(null, dailySales); &#125; else &#123; //假如传参数,代表保存数据 dailySales.push(val); &#125; &#125;; &#125; //这里的需求是获取一周的数据总和//这里的函数可以随时根据需求修改自己的逻辑var weeklyTotal = curryingSales(function() &#123; var sum = 0; for(var i = 0,l = arguments.length; i &lt; l;i++)&#123; sum += arguments[i]; &#125; return sum;&#125;);//保存数据weeklyTotal(1);weeklyTotal(2);weeklyTotal(3);weeklyTotal(4);weeklyTotal(5);weeklyTotal(6);weeklyTotal(7);//获取周数据的总和console.log(weeklyTotal()); 提前返回提前返回就是在对需要重复处理的需求时(例如兼容性处理),先对处理结果进行判断返回,从而避免每次调用的时候都进行判断 12345678910111213141516171819202122232425262728293031323334353637 //需求:兼容IE和普通浏览器的事件添加 // IE:// attachEvent(type, callback)// W3C:// addEventListener(type, callback, useCapture)/** * [addEvent 兼容事件绑定] * @param &#123;[type]&#125; elem [绑定事件的dom元素] * @param &#123;[type]&#125; type [事件的类型] * @param &#123;Function&#125; callback [事件处理程序] * @param &#123;[type]&#125; captrue [是否使用捕获阶段] */// =============缺点：每一次执行addEvent方法都要检测浏览器能力=======================/*var addEvent = function(elem, type, callback, captrue) &#123; // 浏览器支持addEventListener方法 if(window.addEventListener)&#123; elem.addEventListener(type, callback, captrue); &#125; else &#123; // 浏览器支持attachEvent方法 elem.attachEvent('on' + type, callback); &#125; &#125;;*/// ==================科里化提前返回==================var addEvent = function() &#123; // 浏览器支持addEventListener方法 if(window.addEventListener)&#123; return function(elem, type, callback, captrue) &#123; elem.addEventListener(type, callback, captrue); &#125;; &#125; else &#123; // 浏览器支持attachEvent方法 return function(elem, type, callback) &#123; elem.attachEvent('on' + type, callback); &#125;; &#125;&#125;();//通过提前返回,避免了每次调用函数的的时候都会进行兼容性判断 面试题 123456789101112131415161718 var foo = ( function() &#123; var secret = 'secret'; // “闭包”内的函数可以访问 secret 变量，而 secret 变量对于外部却是隐藏的 return &#123; get_secret: function () &#123; // 通过定义的接口来访问 secret return secret; &#125;, new_secret: function ( new_secret ) &#123; // 通过定义的接口来修改 secret secret = new_secret; &#125; &#125;;&#125; () );foo.get_secret (); // 得到 'secret'foo.secret; // Type error，访问不能foo.new_secret ('a new secret'); // 通过函数接口，我们访问并修改了 secret 变量foo.get_secret (); // 得到 'a new secret' 123456789101112131415161718192021222324252627282930313233343536373839var name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function() &#123; return function() &#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); // the windowvar name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function() &#123; var that = this; return function() &#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()()); // My Objectvar age=100; function test() &#123; this.age=50; return function () &#123; return this.age; &#125; &#125; var m=new test(); // console.log(m.age); // 50 console.log(m()); // 100var n=test(); console.log(n()); // 50 12345678910function getRandom()&#123; var random=Math.random(); return function()&#123; return random; &#125;; &#125; var result=getRandom(); for (var i = 0; i &lt; 10; i++) &#123; console.log(result()); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象:创建对象-原型-原型链-继承]]></title>
      <url>%2F2016%2F03%2F12%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[创建对象的方式 工厂模式 语法 12345678function createPerson() &#123; var p = new Object; p.name = 'jerry'; p.age = 18; // some other prop return p;&#125;var p1 = createPerson(); 说明 在函数中定义对象,并定义对象的各种属性 创建对象时，不需要new操作符 在函数的最后返回该对象 构造函数 语法 123456function Person() &#123; this.name = 'jerry'; this.age = 18; // some other prop&#125;var p2 = new Person(); 说明 无需再函数内部创建对象 使用this给当前实例添加成员 函数无需明确return 原型模式 语法 1234function Person() &#123;&#125;Person.prototype.name = 'jerry';Person.prototype.age = 18;var p3 = new Person; 说明 函数中不对成员进行定义 利用prototype属性对成员进行定义 混合模式 语法 1234567function Person(name) &#123; this.name = name;&#125;Person.prototype.getName = function() &#123; return this.name;&#125;;var p4 = new Person('jerry'); 说明 该模式是指混合搭配使用构造函数方式和原型方式 将所有属性定义在函数中（构造函数方式） 将所有方法定义在原型上 推荐使用这样方式创建对象 原型的概念 概念：所谓原型就是指 函数的prototype属性所引用的对象 只要定义一个函数，那么就会创建其原型 由上述函数创建出来的所有对象，都可以直接访问到原型上的成员 作用：实现同类对象之间的数据共享。 获取原型方式 通过函数：.prototype 通过对象：.__proto__ 注意：已__开头和结尾的属性均为非标准属性; 原型 默认具有constructor属性，引用的就是其构造函数 原型特性： 动态性 在已有的原型上扩展成员，直接反映到已创建出来的对象上。 如果置换了已有的原型，那么会反映到后面新创建的对象，而不会影响之前创建的对象 唯一性 由同一个构造函数创建出来的所有对象，都共享一个原型。 不可变性 不能通过对象来修改原型上的成员 共享性 所有的对象都可以直接访问其原型上的成员 原型链 原型链的概念 所谓原型链 就是指 从一个对象到Object.prototype之间存在一条体现继承层次关系的链式结构，这个结构被称为对象的原型链。 本质：链上的每一个对象都是通过__proto__属性连接起来的。 绘制原型链 先简写对象的原型链 将上述原型链上的所有对象绘制在图形上。并且将和原型链相关的属性添加到对象上。 给对象的每一个属性确定指向 如果在图形上的每一个对象的属性都有正确指向，说明绘制完成。 相关结论： Object.prototype的原型为null 默认原型对象的原型为Object.prototype Object.prototype 的部分常用方法简介 hasOwnProperty has 有 own 自己的 property 属性 语法：obj.hasOwnProperty(“propName”) 用来判断指定属性是否为对象自身的，而不是继承过来的;如果是自身的就返回true，否则返回false isPrototypeOf is 是 Prototype 原型 of 的 obj1.isPrototypeOf(obj2) 用来判断obj1 对象 是否为 obj2对象 的原型；如果是，就返回true，否则返回false。 propertyIsEnumerable property 属性 is 是 Enumerable 可枚举的 可以使用for in遍历出来的属性 obj.propertyIsEnumerable(‘propName’) hasOwnProperty升级版： 满足这2个条件返回true，否则返回false 指定的属性必须是对象本身的 该属性必须可枚举 12345678910111213141516171819202122232425var o = &#123;name: 'tom'&#125;;console.log(o.toString()); //[object Object]// 1：hasOwnPropertyconsole.log(o.hasOwnProperty('constructor'));// false console.log(o.hasOwnProperty('name')); // true// 2：isPrototypeOfconsole.log(Object.prototype.isPrototypeOf(o)); // trueconsole.log(o.isPrototypeOf(Object.prototype)); // false// 3：propertyIsEnumerablefor(var k in o)&#123; console.log(k); //name&#125;console.log(o.propertyIsEnumerable('__proto__')); //falseObject.prototype.age = 18;for( k in Object.prototype )&#123; console.log(k); //age&#125;console.log(o.propertyIsEnumerable('age')); //falsefunction foo() &#123; console.log(this); //Number&#125;foo.call(1); 装箱 与 拆箱 将基本数据类型 装换为 复合数据类型，这个过程被称为 装箱 将复合数据类型 装换为 基本数据类型，这个过程被称为 拆箱 强调几点 默认原型对象才具有constructor属性 只有函数具有prototype属性（除了Function.prototype） 任意的对象都具有__proto__属性 instanceof介绍 obj instanceof constructor 规则：如果constructor 的原型 出现在 obj 的原型链上的话，表达式返回值为true，否则false。 12345678910111213var o = &#123;name: 'tom'&#125;;function parent() &#123;&#125;function child() &#123;&#125;var o = Object.create(parent.prototype);// console.log(o.constructor);child.prototype = o;// 手动添加constructor属性，并复制为child构造函数。child.prototype.constructor = child;var c = new child;console.log(c instanceof parent); //true// c -&gt; o -&gt; parent.prototype -&gt; Object.prototype -&gt; null 继承 注意：其他面向对象语言 C# Java swift 类与类之间继承,而在js中，是对象与对象之间的继承 概念：就是指 一个对象有权去访问另一个对象上的成员（属性和方法） 继承的方式 先定义一个父类 12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + '正在吃：' + food);&#125;; 原型链 思想:借助原型可以基于已有的对象创建新对象,将子类的原型指向父类的实例 123456789101112function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat'; // Test Codevar cat = new Cat();console.log(cat.name);//cat console.log(cat.eat('fish'));//cat正在吃fishconsole.log(cat.sleep());//cat正在睡觉!console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 特点 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点 字面量重写原型会中断关系 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的引用属性是所有实例共享的 创建子类实例时，无法向父类构造函数传参ECMAScript5通过新增Object.create()方法规范化了原型式继承，这个方法接收两个参数：一个用作新对象原型的对象和一个作为新对象定义额外属性的对象。 构造继承 思想:使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 12345678910function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);// Tomconsole.log(cat.sleep());// Tom正在睡觉!console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承 思想:为父类实例添加新特性，作为子类实例返回 123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);// Tomconsole.log(cat.sleep());// Tom正在睡觉!console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 拷贝继承 1234567891011121314function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承 思想:通过调用父类构造函数，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 123456789101112function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了,多消耗了一点内存） 寄生组合继承 思想:通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 123456789101112131415161718function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点： 堪称完美 缺点： 实现较为复杂 123456789101112131415161718192021222324252627282930313233343536373839function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125; //实例引用属性 this.features = [];&#125;function Cat(name)&#123;&#125;Cat.prototype = new Animal();var tom = new Cat('Tom');var kissy = new Cat('Kissy');console.log(tom.name); // "Animal"console.log(kissy.name); // "Animal"console.log(tom.features); // []console.log(kissy.features); // []tom.name = 'Tom-New Name';tom.features.push('eat');//针对父类实例值类型成员的更改，不影响console.log(tom.name); // "Tom-New Name"console.log(kissy.name); // "Animal"//针对父类实例引用类型成员的更改，会通过影响其他子类实例console.log(tom.features); // ['eat']console.log(kissy.features); // ['eat']/*原因分析：关键点：属性查找过程执行tom.features.push，首先找tom对象的实例属性（找不到） 那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的features属性中插入值 在console.log(kissy.features)的时候。同上，kissy实例上没有，那么去原型上找 刚好原型上有，就直接返回，但是注意，这个原型对象中features属性值已经变化了*/ 属性搜索原则：当访问对象的某个属性时， 首先，在对象本身上查找，如果找到就返回值，并停止查找； 如果没有找到就向其原型对象上查找，如果找到就返回值，并停止查找； 如果在没有找到，就继续向其原型的原型对象上查找，直到Object.prototype 此时如果找到就返回值，否则值为undefined。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[来自新世界 - 观后感]]></title>
      <url>%2F2016%2F01%2F02%2F%E6%9D%A5%E8%87%AA%E6%96%B0%E4%B8%96%E7%95%8C%20-%20%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在现在日本动漫商业气息极重的年代，《来自新世界》显然是一个另类。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前期花了大量的笔墨描述新的世界、世界观，毫不媚俗的画风和设定以及徐徐而进慢慢展开的节奏让我差一点就弃了。然而慢热总是伴随着惊喜，就如命运石之门那样，当帷幕一点点拉开的时候，当真相显露出来的时候，当最后一幕落下之时，留给我的，是一个纯粹的故事，以及故事之余深深的思考。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是个濒临破碎的世界，也是一个新的世界。是一个乌托邦的世界，又像一个反乌托邦的世界。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主角早季，一个坚强的女孩子，一个经历了几乎所有悲痛的女孩子，一个拥有清浊并吞气量的人。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;町里，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从前有一个女孩，她控制不好咒力，为了避免业魔化，为了人类，他死了；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从前有一个女孩，她是近视，为了避免业魔化，为了人类，他死了；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从前有一个男孩，他的咒力控制不了外泄，为了不扭曲周边的最爱的人，为了人类，他死了；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从前有一个男孩，他的性格懦弱，意志不坚定，为了避免恶鬼和业魔化，本应该死去，但他逃走了；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有那么一个女孩，她坚强又漂亮。为了保护所想要保护的那个逃走的男孩，她随他而去。然而，他们俩都死了；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而他们的孩子，被异族抚养长大，她不是恶鬼，但为了人类，她必须死去。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些人，都是早季最亲的人，然而连记忆也被抹除，连悲伤也无从悲伤，那才是真正的悲伤吧。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——我知道曾经我喜欢过一个人，但是我真的记不清他是谁。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;早季忘记了自己曾经喜欢过的人，无助地失去了真里亚和守这两个好朋友，间接杀死了真里亚和守的女儿，眼睁睁看着父母从容为町而死，与自己的恩师富子生死诀别，她失去了太多，承受了太多。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，如果只是虐，那并不足以为自新写一篇文章。整部动漫最主要的还是这样一个主题：何为人类？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文中的异族，也就是化鼠，曾经的旧人类，里面有一个最标志性的人物——史奎拉。我甚至觉得，他才是主角。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个英雄，也是个叛徒；是一个人渣，也是一个圣人。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它对于化鼠，旧人类，它是一个英雄，也是一个赌徒 。它以全体旧人类为赌注，向着如神明般的新人类，发出了最后的呐喊。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它不择手段，尔虞我诈，杀死母亲，欺骗同类，视士兵如棋子，冷血；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它坚定不屈，为了自由与自尊，奋斗了短暂的一生。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在最后一集中，斯奎拉被审判之时。它的身影是高大，它不是一个猥琐贪便宜化鼠。当史奎拉声嘶力竭地怒吼：我们是人类。反馈回来的，只是嘲笑罢了，只是那嘲笑，有些刺耳。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——比现实更现实，比想象更超俗。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当所有人类拥有神的力量，凡是想象就能够成为现实。这是新人类。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当人类拥有神的力量，却不拥有神的智慧，那么世界都将支离破碎。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当物质文明与精神文明发生了剧烈的断层，这种现象将不可避免。未来的人类社会，该何去何从？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在《来自新世界》的体系中，新人类相当于统治阶层。他们出生就高人一等。他们拥有神一般的力量。随意判定化鼠种群的生死。用自以为是的道德和规则评定这个世界。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;化鼠就像是底层人民，生死不由自己，生活艰苦，没有尊严，没有自由。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实在我看来，谁也没有错。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为人性，化鼠才渴望自由，渴望尊严。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为人性，新人类才会统治化鼠，并且残忍的对待自身群体里不合格的人。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新世界里有爱，有恨，有亲情，有背叛，有嫉妒，有贪婪，有恐惧。没有真正的主角，没有真正的反派，有的只有摆在面前的现实。道德、法律，在这一刻都受到了人性的拷问。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当最后，觉说出了他的发现：化鼠其实是人类自身将自己改造罢了，拥有咒力的新人类为了反抗与统治，改变了自身的基因，加入了愧死机制，同时将没有咒力的人类基因中混入鼠类的基因，将新人类与旧人类区分开，并且用对待畜生的方式对待化鼠。这一刻，我才真正明白了史奎拉的呐喊。哪有什么化鼠，其实——都是人类。人类就是化鼠，化鼠就是人类。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者在最后，并没有给出答案。因为这并没有真正正确的解，这也不是某个人能够去回答的问题。我们的社会该何去何从，人类社会的未来是怎么样的，人类会不会自取灭亡，人类能否处理好可能发生的基因突变，这一切一切的答案都是未知的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后的镜头，是早季写给一千年后的人们的信，衷心的希望一千年后的新世界，会是一个真正的崭新的、充满希望的世界，真正的“新世界”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，用女主回忆中学校墙上的话作为总结：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;「有想象力，就能改变全世界」]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ajax及异步无刷新的场景和方法]]></title>
      <url>%2F2015%2F10%2F04%2Fajax%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E6%97%A0%E5%88%B7%E6%96%B0%E5%9C%BA%E6%99%AF%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[概念 全称Asynchronous JavaScript and XML (异步的JavaScript与XML) 定义 一种请求数据的方式，不需要刷新整个页面 特点及目的 不刷新页面 服务器仅返回需要的数据(速度快,体验好) 引擎 XMLHttpRequest此函数对象是浏览器中的内置对象，在目前的所有浏览器中都支持此对象。 IE7+、Firefox、Chrome、Safari 以及 Opera ActiveXObject 仅IE，支持此对象 ajax流程 请求过程 创建 XMLHttpRequest 对象 连接服务器 发送请求 接收响应数据 创建 非IE 1var xhr = new XMLHttpRequest(); IE 1var xhr = new ActiveXObject('Microsoft.XMLHTTP'); 连接/发送 open() 功能 启动服务器连接请求 参数 请求方式 GET 定义请求方式是通过URL参数将数据提交到服务器的 特性 在 URL 中传输数据，安全性弱， 容量小，一般 URL 的长度最大为 4K 到 10K，长度是有限制的 有缓存 POST 定义是通过将数据作为 send 的参数提交到服务器在发送数据之前，要设置表单提交的内容类型 特性 不在 URL 中传输数据，相对安全性强， 容量大，容量可达到2G，再大就可以使用控件，真正的安全就只有 https 协议。 无缓存 GET 还是 POST？ GET 更简单也更快，并且在大部分情况下都能用。 POST 请求 无法使用缓存文件（更新服务器上的文件或数据库）。 向服务器发送大量数据（POST 没有数据量限制）。 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠。 请求地址 URL 是否异步 true 是（默认为true） false 否 send() 功能 发送服务器连接请求 参数 (可选)stringObj 当发送POST请求时，传入值 setRequestHeader(header, value) 添加 HTTP 头信息 接收 接收到响应后，响应的数据会自动填充XHR对象 相关属性 responseText 如果来自服务器的响应并非 XML，就使用 responseText 属性，该属性返回字符串形式的响应，因此可以直接使用 responseXML 如果来自服务器的响应是 XML（ &quot;text/xml&quot; 或 &quot;application/xml&quot;），而且需要作为 XML 对象进行解析，就使用 responseXML 属性。 请求状态 XMLHttpRequest 对象的 readyState 属性返回请求的当前状态。当请求被发送到服务器时，我们需要执行一些基于响应的任务，每当 readyState 改变时，就会触发 onreadystatechange 事件，readyState 属性存有 XMLHttpRequest 的状态信息。 XMLHttpRequest属性 onreadystatechange 存储函数(或函数名)，每当 readyState 属性改变时，就会调用该函数 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0 请求未初始化。未调用 open() 方法。 1 服务器连接已建立。已调用 open() 方法，正在发送请求。 2 请求已接收，载入完成。open()方法完成，已收到全部响应内容 3 请求处理中，也叫解析。正在解析响应内容。 4 请求已完成，且响应已就绪。响应内容解析完成，可以在客户端调用了。 status 请求结果，也就是 HTTP 状态码。200：OK。404：未找到页面。状态码以2开头的都是成功，304表示从缓存中获取 ajax五步使用法: 建立XMLHTTPRequest对象 注册回调函数 当服务器回应我们了,我们想要执行什么逻辑 使用open方法设置和服务器端交互的基本信息 设置提交的网址,数据,post提交的一些额外内容 设置发送的数据，开始和服务器端交互 发送数据 更新界面 在注册的回调函数中,获取返回的数据,更新界面 示例代码: GET get的数据,直接在请求的url中添加即可 123456789101112131415&lt;script type="text/javascript"&gt;// 创建XMLHttpRequest 对象var xml = new XMLHttpRequest();// 设置跟服务端交互的信息xml.open('get','01.ajax.php?name=fox');xml.send(null); // get请求这里写null即可// 接收服务器反馈xhr.onreadystatechange = function () &#123; // 这步为判断服务器是否正确响应 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 打印响应内容 alert(xml.responseText); &#125; &#125;;&lt;/script&gt; 示例代码: POST 1234567891011121314151617&lt;script type="text/javascript"&gt;// 异步对象var xhr = new XMLHttpRequest();// 设置属性xhr.open('post', '02.post.php' );// 如果想要使用post提交数据,必须添加xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");// 将数据通过send方法传递xhr.send('name=fox&amp;age=18');// 发送并接受返回值xhr.onreadystatechange = function () &#123;// 这步为判断服务器是否正确响应if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125;;&lt;/script&gt; 异步无刷新 异步提交目的: 提升用户体验感 异步提交普通表单 思路html里自带的表单按钮submit是同步提交,在遇到容量较大数据的时候,可能会长时间的响应造成用户体验感差,ajax是异步提交,其诞生就是为了优化用户的体验.在提交的时候需要禁止submit的默认事件,所以无法提交表单数据,可以调用jQuery的serialize方法整理数据,从而避免自己手动添加(字符串拼接之类)的麻烦 1234567891011121314151617$(document).ready(function() &#123; //使用jQuery异步提交表单 $('#表单ID').submit(function() &#123; jQuery.ajax(&#123; url: '要提交的页面', data: $('#表单ID').serialize(),//序列化表单提交数据 type: "POST", beforeSend: function()&#123; //在异步提交前要做的操作 &#125;, success: function()&#123; //在异步提交成功后要做的操作 &#125; &#125;); return false;//禁止表单默认事件 &#125;);&#125;); 带有文件的上传 在涉及文件等二进制数据的提交的时候,可以考虑使用h5的formdata去处理,获取表单dom元素,放入new formdata(dom),将其传给后台即可Formdata有兼容性问题,只有IE10以上支持,如果想要向下兼容的时候,可以考虑用iframe标签处理,或者可以考虑使用插件 FormData对象 定义:ajax操作往往用来传递表单数据。为了方便表单处理，HTML 5新增了一个FormData对象，可以模拟表单。12345678910111213//首先，新建一个FormData对象。var formData = new FormData();//然后，为它添加表单项。formData.append('username', '张三');formData.append('id', 123456);//最后，直接传送这个FormData对象。这与提交网页表单的效果，完全一样。xhr.send(formData);//FormData对象也可以用来获取网页表单的值。var form = document.getElementById('myform');var formData = new FormData(form);formData.append('secret', '123456'); // 添加一个表单项xhr.open('POST', form.action);xhr.send(formData); 上传文件 12345678//假定files是一个"选择文件"的表单元素（input[type="file"]），我们将它装入FormData对象。var formData = new FormData();for (var i = 0; i &lt; files.length;i++) &#123; formData.append("userfile", fileInputElement.files[0]); //获取文件上传元素里面的files[0],这个一般为需要上传的文件主体&#125;//然后，发送这个FormData对象。xhr.send(formData); 文件属性: 1234567//查看文件属性var btn=document.querySelector("#btn");btn.onchange = function () &#123; // console.log(this); var files = this.files; console.log(files)&#125; 复合类型表单数据上传复合型数据表单提交的时候需要在form里设置enctype=multipart/form-data 1&lt;form action="/api/adverts" method="post" enctype="multipart/form-data"&gt; 原生ajax写法 123456789101112131415161718192021//ajax上传代码，放在表单的submit事件回调函数中//我们主要用的是FormData对象，它能够构建类似表单的键值对。form.on('submit',function() &#123;// 检查是否支持FormData if(window.FormData) &#123; var formData = new FormData(); // 建立一个upload表单项，值为上传的文件 formData.append('upload',document.getElementById('upload').files[0]); var xhr = new XMLHttpRequest(); xhr.open('POST', $(this).attr('action')); // 定义上传完成后的回调函数 xhr.onload = function () &#123; if (xhr.status === 200) &#123; console.log('上传成功'); &#125; else &#123; console.log('出错了'); &#125; &#125;; xhr.send(formData); &#125;&#125;); jQuery ajax提交复合类型数据 1234567891011121314151617//需求,提交复合类型表单,成功则自动跳转form.on('submit',function()&#123; $.ajax(&#123; url: $(form).attr('action'),//获取form中提交的url type: $(form).attr('method'),//获取提交方式 data: new FormData(form),//将数据传入FormData创建的对象 processData: false,//禁止对data参数进行序列化处理 contentType: false,//contentType默认application/x-www-form-urlencoded,后台会按照查询字符串方式去解析表单数据,将其关闭可以使后台正常解析数据 dataType: 'json'//数据类型 &#125;).then(data =&gt; &#123; if (data.success) &#123;//假如成功 window.location.href = '/advert'//自动重定向 &#125; &#125;).catch(err =&gt; &#123;//否则报错 window.alert('服务器忙，请稍后重试') &#125;)&#125; 单页面:结合分页插件无刷新(常见于评论模块或者文章模块等等等) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 需求:用requireJS和twbsPagination插件实现评论模块的异步无刷新分页// 入口模块使用 require 方法或者 requirejs 方法定义// 其它的子模块都使用 define 定义require(['jquery', 'underscore', 'moment', 'twbsPagination'],function ($, _, moment) &#123; loadAdverts(1)//进去先执行函数,默认评论显示第一页 // 模板字符串 var tmpStr = $('#tpl').html() // 获取分页的容器 var $pagination = $('.pagination') // 默认配置，默认一共有 20 页 var defaultOpts = &#123;&#125;; // 执行分页插件，开始分页，生成 HTML ，插入文档 $pagination.twbsPagination(defaultOpts); function loadAdverts(pageNumber) &#123; $.ajax(&#123; url: '/api/adverts', data: &#123; pageSize: 5,//每页显示数量 pageNumber: pageNumber &#125;, type: 'get', dataType: 'json' &#125;) .then(data =&gt; &#123; data.ret.list.forEach((advert) =&gt; &#123; advert.ad_start_time = moment(advert.ad_start_time).format('YYYY-MM-DD HH:mm:ss') advert.ad_end_time = moment(advert.ad_end_time).format('YYYY-MM-DD HH:mm:ss') &#125;) $('#tbody').html(_.template(tmpStr)(data.ret)) // 根据请求结果中的总记录数计算总页码 var totalPages = Math.ceil(data.ret.count / 5) // 获取当前的页面 var currentPage = $pagination.twbsPagination('getCurrentPage') // 将原来的分页内容干掉 $pagination.twbsPagination('destroy') // 重新分页，把默认配置项加载出来 $pagination.twbsPagination($.extend(&#123;&#125;, defaultOpts, &#123; startPage: currentPage, totalPages: totalPages &#125;)) .on('page', function (evt, page) &#123; loadAdverts(page) &#125;) &#125;)&#125; 转化数据格式类型 使用JSON对象 JSON.parse()方法:将JSON字符串转化为JavaScript对象 JSON.stringify()方法:将JavaScript对象,转化为JSON字符串 使用eval()方法使用eval()方法需要注意的是,需要将内容使用()括号包裹起来,如示例代码 12345678&lt;script type="text/javascript"&gt; var jsonStr =&#123; "name":"fox", "age":18, "skill":"前端"&#125;`;var jsonObj = eval('('+jsonStr+')'); console.log(jsonObj);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象:词法作用域-作用域-作用域链]]></title>
      <url>%2F2015%2F08%2F05%2F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
      <content type="text"><![CDATA[词法作用域 概念: 词法作用域规定变量的作用是在定义时，而不是在执行时决定的 没有块级作用域 只有函数可以限定作用域 全局变量 不在任何函数内定义的变量(或者隐式全局) 在任何位置都可以被访问到 局部变量 在函数内部定义的变量（包括参数声明） 只有在函数内部可以被访问到 作用域链 作用域种类 弱类型语言：大部分为 静态作用域 强类型语言：动态作用域 变量的搜索原则： 当访问一个变量时，首先在当前作用域上查找，如果找到就直接使用，并停止查找； 如果没有找到，就会向上一级作用域上查找，如果找到就直接使用，并停止查找； 如果还没有找到就继续向上一级作用域查找，直到全局作用域，如果找到就直接使用，并停止查找； 否则报错（xxx is not defined.） 绘制作用域链的步骤 全局作用域 为 0 级链。将在当前作用域上的变量、对象等数据，绘制在该链上。 函数可以限定作用域，在绘制过程中，只要遇到函数，就在此基础上扩展一条新俩链，级别为 当前级别 + 1； 重复2步骤，直到所有函数都扩展出了新链为止。 在变量搜索的时候，如果访问的是全局变量，那么会搜索整个作用域链。性能会降低。在实际开发时，可以将常用的全局对象传入局部变量内。在同级链上的变量，互相不能访问。 示范:123456789101112131415var f = 1; function foo() &#123; var f = 2; console.log(f); // 2 function fn() &#123; var f = 3; console.log(f); // 3 &#125; function ffn() &#123; console.log(f); //2 &#125; fn(); ffn();&#125;foo();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[offsetTop、clientTop、scrollTop、offsetTop概念和使用]]></title>
      <url>%2F2015%2F06%2F26%2FoffsetTop%E3%80%81clientTop%E3%80%81scrollTop%E3%80%81offsetTop%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidth scrollHeight: 获取对象的滚动高度。 scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 scrollWidth:获取对象的滚动宽度 offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度 offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 event.clientX 相对文档的水平座标 event.clientY 相对文档的垂直座标 event.offsetX 相对容器的水平坐标 event.offsetY 相对容器的垂直坐标 document.documentElement.scrollTop 垂直方向滚动的值 event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量 这里是JavaScript中建造迁移转变代码的常用属性 页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; 网页可见区域宽： document.body.offsetWidth （包含边线的宽）; 网页可见区域高： document.body.offsetHeight （包含边线的宽）; 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 网页正文项目组上： window.screenTop; 网页正文项目组左： window.screenLeft; 屏幕辨别率的高： window.screen.height; 屏幕辨别率的宽： window.screen.width; 屏幕可用工作区高度： window.screen.availHeight; offset 假设 obj 为某个 HTML 控件。obj.offsetTop 指 obj 间隔上方或上层控件的地位，整型，单位像素。obj.offsetLeft 指 obj 间隔左方或上层控件的地位，整型，单位像素。obj.offsetWidth 指 obj 控件自身的宽度，整型，单位像素。obj.offsetHeight 指 obj 控件自身的高度，整型，单位像素。我们对前面提到的“上方或上层”与“左方或上层”控件作个申明。 例如：1234567&lt;div id="tool"&gt;&lt;input type="button" value="提交"&gt;&lt;input type="button" value="重置"&gt;&lt;/div&gt; “提交”按钮的 offsetTop 指“提交”按钮距“tool”层上边框的间隔，因为距其上边比来的是 “tool” 层的上边框。“重置”按钮的 offsetTop 指“重置”按钮距“tool”层上边框的间隔，因为距其上边比来的是 “tool” 层的上边框。“提交”按钮的 offsetLeft 指“提交”按钮距“tool”层左边框的间隔，因为距其左边比来的是 “tool” 层的左边框。“重置”按钮的 offsetLeft 指“重置”按钮距“提交”按钮右边框的间隔，因为距其左边比来的是“提交”按钮的右边框。 以上属性在 FireFox 中也有效。 另外：我们这里所说的是指 HTML 控件的属性值，并不是 document.body，document.body 的值在不合浏览器中有不合申明（实际上大多半景象是因为对 document.body 申明不合造成的，并不是因为对 offset 申明不合造成的），点击这里查看不合点。 题目：offsetTop 与 style.top 的差别 筹办常识：offsetTop、offsetLeft、offsetWidth、offsetHeight 我们知道 offsetTop 可以获得 HTML 元素间隔上方或外层元素的地位，style.top 也是可以的，二者的差别是： 一、offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。二、offsetTop 只读，而 style.top 可读写。三、若是没有给 HTML 元素指定过 top 样式，则 style.top 返回的是空字符串。 offsetLeft 与 style.left、offsetWidth 与 style.width、offsetHeight 与 style.height 也是同样事理。 题目：clientHeight、offsetHeight和scrollHeight 我们这里说说四种浏览器对 document.body 的 clientHeight、offsetHeight 和 scrollHeight 的申明，这里说的是 document.body，若是是 HTML 控件，则又有不合，点击这里查看。这四种浏览器分别为IE（Internet Explorer）、NS（Netscape）、Opera、FF（FireFox）。 clientHeight 大家对 clientHeight 都没有什么贰言，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个对象条以下到状况栏以上的这个区域，与页面内容无关。 offsetHeight IE、Opera 认为 offsetHeight = clientHeight + 迁移转变条 + 边框。 NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。 scrollHeight IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。 NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。 简单地说,clientHeight 就是透过浏览器看内容的这个区域高度。 NS、 FF 认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于便是 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。 IE、Opera 认为 offsetHeight 是可视区域 clientHeight 迁移转变条加边框。scrollHeight 则是网页内容实际高度。 同理clientWidth、offsetWidth 和 scrollWidth 的申明与上方雷同，只是把高度换成宽度即可。 然则FF 在不合的 DOCTYPE 中对 clientHeight 的申明不合， xhtml 1 trasitional 中则不是如上申明的。其它浏览器则不存在此题目。 题目：scrollTop、scrollLeft、scrollWidth、scrollHeight scrollTop 是“卷”起来的高度值，示例： 12345678910111213&lt;div style="width:100px;height:100px;background-color:＃FF0000;overflow:hidden;" id="p"&gt;&lt;div style="width:50px;height:300px;background-color:＃0000FF;" id="t"&gt;若是为 p 设置了 scrollTop，这些内容可能不会完全显示。&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var p = document.getElementById（"p"）;p.scrollTop = 10;&lt;/script&gt; 因为为外层元素 p 设置了 scrollTop，所以内层元素会向上卷。 scrollLeft 也是类似事理。 我们已经知道 offsetHeight 是自身元素的宽度。 而 scrollHeight 是内部元素的绝对宽度，包含内部元素的隐蔽的项目组。 上述中 p 的 scrollHeight 为 300，而 p 的 offsetHeight 为 100。 scrollWidth 也是类似事理。 IE 和 FireFox 周全支撑，而 Netscape 和 Opera 不支撑 scrollTop、scrollLeft（document.body 除外）。 揭晓时候：2007-10-15 20:20:16 题目：offsetTop、offsetLeft、offsetWidth、offsetHeight 返回对象的offsetLeft属性值和到当前窗口左边的真实值之间的间隔，可以懂得为边框的长度 一向以来对offsetLeft，offsetTop，scrollLeft，scrollTop这几个办法很含混，花了一天的时候好好的进修了一下．得出了以下的成果： - offsetTop: 当前对象到其上级层顶部的间隔. 不克不及对其进行赋值.设置对象到页面顶部的间隔请用style.top属性. - offsetLeft: 当前对象到其上级层左边的间隔. 不克不及对其进行赋值.设置对象到页面左部的间隔请用style.left属性. - offsetWidth: 当前对象的宽度. 与style.width属性的差别在于:如对象的宽度设定值为百分比宽度，则无论页面变大还是变小，style.width都返回此百分比，而offsetWidth则返回在不合页面中对象的宽度值而不是百分比值 - offsetHeight: 与style.height属性的差别在于:如对象的宽度设定值为百分比高度，则无论页面变大还是变小，style.height都返回此百分比，而offsetHeight则返回在不合页面中对象的高度值而不是百分比值 - offsetParent: 当前对象的上级层对象. 重视.若是对象是包含在一个DIV中时，此DIV不会被当做是此对象的上级层，（即对象的上级层会跳过DIV对象）上级层是Table时则不会有题目. 哄骗这个属性，可以获得当前对象在不合大小的页面中的绝对地位． 获得绝对地位脚本代码 123456789101112function GetPosition(obj)&#123; var left = 0; var top = 0; while(obj != document.body) &#123; left = obj.offsetLeft; top = obj.offsetTop; obj = obj.offsetParent; &#125; alert("Left Is : " + left + "\r\n" + "Top Is : " + top);&#125; scrollLeft : 对象的最左边到对象在当前窗口显示的局限内的左边的间隔． 便是在呈现了横向迁移转变条的景象下，迁移转变条拉动的间隔． scrollTop 对象的最顶部到对象在当前窗口显示的局限内的顶边的间隔． 便是在呈现了纵向迁移转变条的景象下，迁移转变条拉动的间隔． 我们这里说说四种浏览器对 document.body 的 clientHeight、offsetHeight 和 scrollHeight 的申明，这里说的是 document.body，若是是 HTML 控件，则又有不合，点击这里查看。 这四种浏览器分别为IE（Internet Explorer）、NS（Netscape）、Opera、FF（FireFox）。 clientHeight 大师对 clientHeight 都没有什么贰言，都认为是内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度，一般是最后一个对象条以下到状况栏以上的这个区域，与页面内容无关。 offsetHeight IE、Opera 认为 offsetHeight = clientHeight + 迁移转变条 + 边框。 NS、FF 认为 offsetHeight 是网页内容实际高度，可以小于 clientHeight。 scrollHeight IE、Opera 认为 scrollHeight 是网页内容实际高度，可以小于 clientHeight。 NS、FF 认为 scrollHeight 是网页内容高度，不过最小值是 clientHeight。 简单地说 clientHeight 就是透过浏览器看内容的这个区域高度。 NS、 FF 认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于便是 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。 IE、Opera 认为 offsetHeight 是可视区域 clientHeight 迁移转变条加边框。scrollHeight 则是网页内容实际高度。 同理 clientWidth、offsetWidth 和 scrollWidth 的申明与上方雷同，只是把高度换成宽度即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[那些再也回不去的]]></title>
      <url>%2F2015%2F06%2F11%2F%E9%82%A3%E4%BA%9B%E5%86%8D%E4%B9%9F%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总有些时候，我们得面临抉择，面临离散。在光阴的长河中，总是感慨自己的无力。终究，我们只是生活在三维的空间中，没有办法跨越时间的阻碍，望穿过去与未来。每前进一步，就是在与不断消失的过去说再见。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们，再也回不去，回不去那些美丽抑或悲伤的日子。在人生漫漫的旅行中，记忆便渐渐泛着美丽的光晕，过去变得模糊不清。那些以为会刻骨铭心的，也会淡淡抹去。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再也回不去了。在高中外的门口向里眺望，想着那些年的夏天，在课堂上刻苦奋斗的大家，在操场上肆意飞扬的日子，那些的骄傲不羁 。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再也回不去了。那一年在大学的门口徘徊踌躇，在恐惧与未知中前行的日子。在训练场上挥洒的汗水，在木兰湖中晒伤的皮肤，在一次次摔倒后倔强的站起来的身影，在毕业时哭着的面庞。再也回不去了。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高中时，听着SHE的不想长大，总有种为赋新词强说愁的感觉。如今再重新听，这何尝不是每个即将告别青涩的人的呐喊。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去的一切，就像一根根丝带，走的越远，缠的越紧。也许今天的我们，还可以无所畏惧的挣脱束缚，走向自己想要的未来。但是时间越久，选择的次数越多，越是对过去有一种不舍。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也许，我们所憎恨的今天，是明天你再也回不去的美好记忆。你现在的每一秒，都是每个昨天去世的人所向往的明天。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有选择，我还会选择重来，因为有太多的遗憾。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，人永远只能往前走，既然我们已经有了那么多的遗憾，那么就从现在开始，争取不留遗憾的，一步步往下走。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天，我在这里，对着那些再也回不去的日子，说再见，再也不见。 最后推荐echo上我们学校的童鞋的原创歌曲 《你回不去》 。http://www.app-echo.com/sound/info?sound_id=557569]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery总结]]></title>
      <url>%2F2015%2F06%2F06%2FjQuery%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[jQuery特点： 连式编程 链式编程原理：return $(this); end(); // 结束当前链最近的一破坏性操作，并且返回匹配元素之前的状态 隐式迭代(隐式循环) 在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环 如果获取的是多元素的值，大部分情况下返回的是第一个元素的值 入口函数 $(document).ready(function () {}); jQuery(document).ready(function () {}); $(window).load(function () {});Jquery和dom相互转换 jq转dom 数组通过索引获得 jqDiv = [jqDiv[0],jqDiv[1],jqDiv[2]]; dom转jq 用$ divArr = $(divArr); claArr = $(claArr); idbox = $(idbox);选择器 基本选择器 标签选择器 var jqDiv = $(“div”); 类名选择器 var jqCla = $(“.box”); id选择器 var jqId = $(“#box”); 层级选择器 后代（子子孙孙） var jqLi = $(“ul li”); 子代（亲） var jqChi = $(“ul&gt;li”); 过滤选择器 奇数 var jqOdd = $(“ul li:odd”); 偶数 var jqEven = $(“ul li:even”); 索引值 var jqEq = $(“ul li:eq(0)”); 特殊 var jqEq = $(“ul li:last/first”); 筛选选择器 find() $(“ul”).find(“li”).css(“background”,”pink”); 查找他的所有的后代元素，子子孙孙 children() $(“ul”).children(“li”).css(“background”,”red”); jquery对象调用后，查找他的所有的子元素。亲儿子 eq() $(“ul”).children(“li”).eq(0).css(“background”,”yellow”); 是去他的对象中找，而不是去的对象中的子元素中找 siblings() $(“ul”).children(“li”).eq(0).siblings(“li”).css(“background”,”green”); 返回调用者的所有指定的兄弟jquery对象 parent() console.log($(“ul”).children(“li”).eq(0).parent(“ul”)); 返回调用者的父元素jquery对象更多选择器内容见 http://www.w3school.com.cn/jquery/jquery_ref_selectors.asp动画 显示和隐藏 | show（）hide（） 括号里面值可以填数字（毫秒值），出现渐变效果 括号里面填单词 slow normal fast 对应数字（600 400 200） 带参数，两个（时间，回调函数） 先变化，变化完毕之后执行回调函数,实现较为复杂的动画 什么都不写等于display=“none”/“block”,瞬间变化 注意： 渐变的效果包括margin等属性也在渐变 toggle（） 切换 比如：$(“div”).toggle(1000); 就是兼具了显示和隐藏的效果，等同于show（1000）和hide（1000） 滑入和滑出 | slideDown（）slideUP（） 大致特点同上 区别在括号里面不写参数的时候，是正常速度滑入滑出而不是直接显示或者隐藏 slideToggle也与toggle同理 淡入和淡出 | fadeIn（）fadeOut（） 同滑入滑出，括号里面不写参数正常速度淡入淡出 fadeToggle fadeTo（） 参数:时间，透明度，回调函数(可选) 注意：括号里面不要不写内容 自定义动画 animate（） 两个或者三个参数: json，时间，回调函数(可选) json可以写width height top left等等等，不支持背景色 $(“div”).animate(json,2000,function(){}) 可以模拟前面三种 停止动画 stop（） 有两个参数，都是布尔类型，默认都是false，一般不用写 第一个true后续动画不执行，false后续执行。第二个true立刻完成当前动画，false立刻停止当前动画操作样式的方式 css 赋值（两个参数） $(“div”).css(“width”,100) 获取属性值（一个参数） $(“div”).css(“width”) 赋值：一次多个属性（一个参数json） 12 var json=&#123;“width”:300,&quot;height&quot;:300&#125;;$(&quot;div&quot;).css(json) 类 添加类addClass（不会删除原来的类） 删除类removeClass（不会影响其他的类） 判断是否有类hasClass，多个类只要有一个满足即可 切换样式 toggleClass （有类删除 无类添加）节点操作 创建元素 html（’’） 括号里面写标签名 特点: 容易覆盖原有的元素 字符串具有不可变性，如果原有的字符串加上新创建的元素，那么原有的元素添加的事件会消失 $（“&lt;&gt;&lt;/&gt;”） 创建出来的是Jquery对象 添加元素 append（） 向每个匹配的元素内部追加内容。 appendTo（） 把所有匹配的元素追加到指定的元素元素集合中。 格式: A.appendTo（B）也就是把a追加到b中 prepend（） 向每个匹配的元素内部追加内容在最前面 prependTo（） 把所有匹配的元素追加到指定的元素元素集合中的最前面 格式: A.prependTo（B）也就是把a追加到b中子元素的第一位 after（） 以兄弟元素的形式添加在调用者之后 格式: 调用者.after(创建的元素) before（） 以兄弟元素的形式添加在调用者之前 格式: 调用者.before(创建的元素) 元素的清空和删除 清空元素 empty（） 父元素.empty（）|子元素全部删除 html（“”） 父元素.html(“”)|子元素全部清空 删除指定元素（自杀） 要删除的元素.remove（） 复制元素 clone（） 格式: 要复制的元素.clone（） 特点：深层复制，即里面所有内容包括子元素都复制过来操作form表单（属性） 属性操作 注意：Jquery不支持直接绑定自定义属性 设置自定义属性用attr（“属性”，值） 删除属性removeAttr（“属性”） 获取值 对象.attr（“”） prop和attr的区别 功能相同 attr是一次性的 attr获取的是DOM属性，普通属性操作用attr prop获取的是html元素的固有属性，所以在操作表单属性时候用prop 值,内容 val（） 无参数的时候获取值，带参数的时候就是赋值（标签中的value，也不识别标签） text（） 无参数的时候获取值，带参数的时候就是赋值（不识别标签，标签以字符串形式输出） html（） 无参数的时候获取值，带参数的时候就是赋值（识别标签，会输出标签）bom height（）width（） 赋值不带单位，获取时候也不带单位 与css（）的区别在于css获取的时候带单位，它获取的是Number类型，css是String2 offset（） 获取或设置元素相对于文档的位置 无参数表示获取，返回值为json格式：{left:num, top:num}，值是相对于document的位置 注意：设置offset后，如果元素没有定位(默认值：static)，则被修改为relative position（） 作用：获取相对于其最近的具有定位的父元素的位置 返回值为对象：{left:num, top:num} 注意：只能获取，不能赋值。可用css代替 scrollTop（） 获取或者设置元素垂直或者水平方向滚动的位置 无参数表示获取偏移 有参数表示设置偏移，参数为数值类型事件绑定 bind 第一个参数：事件类型 第二个参数：事件处理程序 作用：给匹配到的元素直接绑定事件 优点：可以绑定多个事件 缺点：要绑定事件的元素必须存在文档中。 delegate(老版本的jq) 第一个参数：selector，要绑定事件的元素 第二个参数：事件类型 第三个参数：事件处理函数 特点：性能高，支持动态创建的元素 作用：给匹配到的元素绑定事件，对支持动态创建的元素有效 delegate一般给父级元素的某个指定的子元素绑定，解绑的时候同理 on 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件） 第二个参数：selector, 执行事件的后代元素 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用 第四个参数：handler，事件处理函数 $(selector).on(events[,selector][,data],handler); 作用：给匹配的元素绑定事件，包括了上面所有绑定事件方式的优点 on一般给父级元素的某个指定的子元素绑定，解绑的时候同理事件解绑 unbind $(selector).unbind(); 解绑所有的事件 $(selector).unbind(“click”); 解绑指定的click事件 delegate $( selector ).undelegate(); //解绑所有的delegate事件 $( selector).undelegate( “click” ); //解绑所有的click事件 若是通过父元素绑定的子元素的事件，selector必须是绑定了click事件的元素的父元素 off 解绑匹配元素的所有事件$(selector).off(); 解绑匹配元素的所有click事件$(selector).off(“click”); 解绑所有代理的click事件，元素本身的事件不会被解绑 $(selector).off( “click”, “**” ); 若是通过父元素绑定的子元素的事件，selector必须是绑定了click事件的元素的父元素事件触发 简单事件触发$(selector).click() trigger方法触发事件$(selector).trigger(“click”); triggerHandler触发 事件响应方法，不触发浏览器行为$(selector).triggerHandler(“focus”);事件对象 event.data 传递给事件处理程序的额外数 event.currentTarget 等同于this，当前DOM对象 event.pageX 鼠标相对于文档左部边缘的位置 event.target 触发事件源，不一定===this event.stopPropagation()； 阻止事件冒泡 event.preventDefault(); 阻止默认行为 event.type 事件类型：click，dbclick… event.which 鼠标的按键类型：左1 中2 右3 event.keyCode 键盘按键代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 总结]]></title>
      <url>%2F2015%2F05%2F13%2FCSS3%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[文字与字体 文字阴影text-shadow 语法text-shadow：pageX+px pageY+px Blur+px color 参数介绍 可以给一个对象应用一组或多组阴影效果，方式如前面的语法显示一样，用逗号隔开。text-shadow: X-Offset Y-Offset Blur Color中X-Offset表示阴影的水平偏移距离，其值为正值时阴影向右偏移，如果其值为负值时，阴影向左偏移；Y-Offset是指阴影的垂直偏移距离，如果其值是正值时，阴影向下偏移反之其值是负值时阴影向顶部偏移；Blur是指阴影的模糊程度，其值不能是负值，如果值越大，阴影越模糊，反之阴影越清晰，如果不需要阴影模糊可以将Blur值设置为0；Color是指阴影的颜色，其可以使用rgba色。 隐藏文字(要实现溢出时产生省略号的效果，还须定义另外两条属性) text-overflowtext-overflow只是用来说明文字溢出时用什么方式显示 参数 clip:超出部分裁切 ellipsis:超出部分用省略号代替 overflow：hidden溢出内容为隐藏 white-space:nowrap强制文字在一行显示 控制连续文本换行word-wrap 参数 normal:浏览器默认值 break-word:break-word设置在长单词或 URL地址内部进行换行 嵌入式字体 @font-face能够加载服务器端的字体文件，让浏览器端可以显示用户电脑里没有安装的字体。 语法 1234@font-face &#123; font-family : 字体名称; src : 字体文件在服务器上的相对或绝对路径;&#125; 这里是定义用的哪种字体和路径，在其他css属性中使用这种字体的就会从这个路径去加载渲染字体 边框 圆角border-radius 写法:border-radius:1参数或四参数，参数为px或百分比。一参数为四个圆角的弧度，四参数顺序为左上，右上，右下，左下 阴影box-shadow 参数:X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式] 前两个参数为必填参数其他为可选参数，投影方式默认为外阴影方式，可以设置为inset内阴影方式。阴影颜色默认为黑色可以添加多个阴影，用逗号隔开。 border-image边框图片 语法:border-image：url（） n n n n 平铺方式 平铺方式 repeat 重复 round 平铺 stretch 拉伸 颜色变化 渐变 线性渐变 语法:background-image:linear-gradient(to bottom,red,orange);background-image:渐变方式（方向可以是to left等也可以是deg，颜色后面可以跟百分比值） 径向渐变 语法:radial-gradient（渐变的椭圆左右半径 渐变的椭圆的上下半径 at 渐变的椭圆的定位x位置 渐变的椭圆定位y位置，颜色，颜色） 背景相关 background-origin(定义背景显示区域) 参数 border-box:背景从边框开始，也就是压在边框上 padding-box:背景从内边距开始（相当于默认值） content-box:背景从内容区开始（比如内边距是20px那就会在盒子内20px的位置开始渲染背景） background-clip(定义背景裁剪区) 参数 border-box:默认值，从边框向外裁剪 padding-box:向内填充向外裁剪 content-box:从内容区域外裁剪背景 no-clip:不裁切 background-size(定义背景图片显示) auto 长度值px:可以设置宽高值，当只有一个值时默认为宽度高度等比缩放 百分比:将背景图标的宽高变成容器宽高的百分比 cover:背景缩放到覆盖整个容器 contain:背景缩放到覆盖容器的一边为止 multiple background(多背景) 概念和用法:在一个元素内，可以同时写N个url路径来呈现多张背景图，但是需要用到background-position来将他们定位到不同的位置。还需要background-repeat：no-repeat；其他上述的属性也可以定义 123456789示例代码 .demo&#123;连写background：url(&quot;1.jpg&quot;) no-repeat top left, url(&quot;2.jpg“) no-repeat top bottom;&#125;分开写background-images&#123;url(&quot;1.jpg&quot;) ,url(&quot;2.jpg&quot;;)&#125;下面的省略了，注意看我代码中的标点符号 选择器 属性选择器 E[attr^=val]:选中的是attr属性的值的开头是val的E元素 E[attr$=val]:选中的是attr属性的值的结尾是val的E元素 E[attr*=val]:选中的是attr属性的值具有val的E元素 结构性伪类选择器 ：root 根选择器选择到的是最高的根节点也就是等同于html。ie9以下不支持。可以当作一种hack方法来使用。 ：not 否定选择器可以选取除某个元素之外的所有元素.比如 123 input：not（[type=&quot;submit&quot;]）&#123;border:1px solid red; &#125; 除了密码表单其他表单的边框色都变成红色 ：empty 空选择器用来选择没有任何内容的元素 ：target 目标选择器写法#id：target 与锚点有关系例如一个a标签的 href=“id” 一个div的id=id那么#id：target就是当a标签被点击后 那个id是id的div的样式 ：first-child 选择父元素的第一个子元素的元素 :last-child 元素的最后一个子元素 :nth-child(n)用来定位父元素的多个特定的子元素，n是参数，也可与是n+x等表达式，但参数n的起始值是1，而不是0.也就是说当n为0时匹配不到任何元素。 :nth-last-child(n)与：nth-child()相反是从最后的子元素开始计算，来选择特定的元素 元素类型伪类选择器 :first-of-type:first-of-type 类似于：first-child 只不过first-of-type 是用来定位父元素下的某个【类型】的第一个子元素 :last-of-type用来定位父元素下的某个【类型】的最后一个子元素 :nth-of-type(n)计算父元素中指定的某种【类型】的子元素 唯一后代伪类选择器 ：only-child选择器选中的是父元素只有一个子元素的元素 ：only-of-type表示如果被选中父元素内有多个子元素，选择器就可以选中唯一类型的子元素。比如 12345 &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 用div：only-of-type选择到的就是p元素 表单状态选择器 :enable选择到的是可用的表单 :disable选择到被禁用的表单 :checked选中的是选中状态的表单 :read-only该属性是选中只读状态的表单。表单里面有这样一条属性readonly=”readonly”表示该表单只可读 :read-write与read-only相反，表示选中的是可编辑表单 伪元素选择器 ::selection选择的是被鼠标选中的文本 ::after和::befor::before和::after这两个主要用来给元素的前面或后面插入内容，这两个常和”content”配合使用，在使用时通常要灵活的考虑到display属性 定位 z-index 动画 transition复合过渡属性 transition-property：指定过渡或动态模拟的CSS属性 transition-duration：指完成过渡所需时间 transition-timing-function：指定过渡函数或贝塞尔曲线 linear 相同速度开始至结束的过渡效果 ease 慢速开始，然后变快，然后慢速结束 ease-in 慢速开始的过渡效果 ease-out 慢速结束的过渡效果 ease-in-out 以慢速开始和结束的过渡效果 cubic-bezier(n,n,n,n) 贝塞尔曲线参数 transition-delay： 过渡延迟时间 变形 rotate（deg）旋转通过指定的参数来控制元素旋转正值为顺时针，负值为逆时针 skew（x,y）扭曲可以让元素倾斜显示，可以让元素以中心位置围绕x，y轴按照一定角度倾斜。会改变元素形状。 scale(x,y) 缩放让元素根据中心原点对对象进行缩放 translate(x,y)位移就是字面意思，可以让元素横向纵向移动 matrix()数学矩阵参数有个scaleX(),skewX(),skewY(),scaleY(),translateX(),translateY()分别为横向伸缩，横向扭曲，纵向扭曲，纵向伸缩，横向位移，纵向位移。默认参数值为1，0，0，1，0，0 transform-origin：原点元素的坐标原点默认值为center，center或者50%，50% 更改原点 布局方式 盒模型 box-sizing border-box元素的宽度=内容的宽度包含border和padding也就是说写了宽100px，不管加边框还是内间距盒子的大小都不会变。这其实是ie的传统盒模型 IE6以下的版本或者IE6-7的怪异模式中就是这样的 content-box W3C标准盒模型 多列布局 columns 用途:复合属性可以让元素内容以多少宽度的n列显示 用法:columns: 200px 2; column-count 列数number column-width 列宽px column-gap 列间距px column-rule 列边框 与盒子边框一样 column-span: 跨列 all跨所有列 none默认参数 例子 1234p:nth-child(2n)&#123; column-span:all;&#125;//偶数列的p都跨列显示。就是和单列显示差不多的意思 伸缩布局 应用场景Flexbox布局常用于设计比较复杂的页面，可以轻松的实现屏幕和浏览器窗口大小发生变化时保持元素的相对位置和大小不变，同时减少了依赖于浮动布局实现元素位置的定义以及重置元素的大小。 创建flex容器flexbox布局的第一步是需要创建一个flex容器。为此给元素设置display属性的值为flex。在Safari浏览器中，你依然需要添加前缀-webkit， display:flex flex项目显示 flex-direction row默认值 呈列显示column flex布局(根据主轴方向使用不同的属性如果是呈列显示那么主轴就是水平方向，如果呈行显示那么主轴方向就是垂直) flex移动到顶部 垂直方向的设置方式 align-items(参数flex-start) 水平方向的设置方式 justify-content(参数flex-start) flex项目移到左边 flex-direction:column时 align-items:flex-start flex-direction:row时 justify-content:flex-start flex项目移到右边 flex-direction:column时 align-items:flex-start flex-direction:row时 justify-content:flex-end 水平垂直居中 justify-content或者align-items为center 等比伸缩两个兄弟盒子一个为flex:100一个为flex:200他俩就是以1：2的关系占满父盒子的宽或者高]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数相关概念及this指向]]></title>
      <url>%2F2015%2F04%2F08%2F%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8Athis%E6%8C%87%E5%90%91%2F</url>
      <content type="text"><![CDATA[函数创建方式 声明式 1234function 函数名([形参列表]) &#123; 函数体; [return [函数返回值];]&#125; Function() 1var 函数名 = new Function(["形参列表"],"函数体"); 直面量 1234var 函数名 = function ([形参列表]) &#123; 函数体; [return [函数返回值];] &#125;; 函数的方法 apply(第一个参数为this指向的对象obj,第二个参数是一个数组,作为传入obj的参数) 将函数作为对象的方法来调用,将参数以数组形式传递给该方法 12345678function sayColor(sPrefix,sSuffix) &#123; alert(sPrefix + this.color + sSuffix);&#125;;var obj = new Object();obj.color = "blue";sayColor.apply(obj, ["The color is ", "a very nice color indeed."]); call 将函数作为对象的方法来调用将指定参数以列表形式传递给该方法 12345678function sayColor(sPrefix,sSuffix) &#123; alert(sPrefix + this.color + sSuffix);&#125;;var obj = new Object();obj.color = "blue";sayColor.call(obj, "The color is ", "a very nice color indeed."); call和apply的区别 fn.call(thisObj, arg1, arg2, arg3, …argN); thisObj在fn函数内部的this指向（必需）,不需要指向的时候可以填null arg1, arg2, arg3, …argN函数fn在执行时，传入的实参。（可选） fn.apply(thisObj, [array]); thisObj在fn函数内部的this指向(必需),不需要指向的时候可以填null 数组对象将数组的所有元素值当做fn执行时的实参。（可选） fn.bind(thisObj,[array]) toString 返回函数的字符串表示形式 arguments伪数组 功能 存放实参的参数列表（伪数组对象） 特性 仅能在函数体内使用 伪数组对象 函数声明时自动初始化 属性 length 获取函数实参的长度 callee 返回当前正在执行的函数 匿名函数的递归调用 caller 返回调用当前正在执行函数的函数名 函数参数 参数类型 形参 定义函数时使用的参数 接收调用该函数时传递的参数 实参 调用函数时传递给函数的实际参数 特性 参数个数没有限制 实参 &lt; 形参 多余形参 = undefined 实参 &gt; 形参 多余实参被忽略 形参与实参一一对应 参数的数据类型没有限制 通过arguments对象方法实参数组 参数始终按值传递 基本类型 传值 引用类型 传址 指针标识 this 指向当前操作对象 callee 指向参数集合所属函数 prototype 指向函数的原型属性 constructor 指向创建该函数的构造函数 函数的调用模式以及函数中this指向 函数中的this指向,不是在创建的时候确定的,而是在被调用的时候才会被确定 普通函数执行模式：声明一个函数后，直接通过函数的名字调用。 1234function foo() &#123; console.log(this); // this -&gt; window&#125;foo(); // 普通函数执行模式 构造函数模式： 通过 new 操作符 创建一个对象，此时该函数的执行模式为 构造函数模式 12345function fn() &#123; console.log(this); // this -&gt; 构造函数创建出来的对象&#125;var f = new fn; // 构造函数执行模式var ff = new fn; 方法调用模式：通过对象来调用 1234var o = &#123;say: function() &#123; console.log(this); // this -&gt; 方法的调用者， 即对象o。&#125;&#125;;o.say(); // 方法调用模式 上下文模式(call/apply模式): 作用：动态改变this的指向 this -&gt; call|apply方法的第一个参数 12345function print() &#123; console.log(this.name);&#125;var obj = &#123;name: "tom"&#125;;print.call(obj); // tom 上下文模式作用及使用场景 借用方法 数组合并 借用Math对象方法 获取对象类型 实现伪数组对象转换为真数组 实现借用构造函数继承 123456789101112131415function Person(name, age, gender, high) &#123; this.name = name; this.age = age; this.gender = gender; this.high = high; &#125;function Teacher(name, age, gender, high, codeNo, cellphoneNo) &#123; Person.apply(this, Array.prototype.slice.call(arguments, 0, 4)); this.codeNo = codeNo; this.cellphoneNo = cellphoneNo;&#125;var t = new Teacher('guojing', 18, 'boy', '226', '91248', '13813813811');console.log(t); 改变this指向]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式的使用]]></title>
      <url>%2F2015%2F03%2F09%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[简介正则表达式是被用来匹配字符串中的字符组合的模式。在JavaScript中，正则表达式也是对象。这种模式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。 创建正则表达式 使用一个正则表达式字面量1var re = /ab+c/; 正则表达式字面量在脚本加载后编译。若你的正则表达式是常量，使用这种方式可以获得更好的性能。 调用RegExp对象的构造函数1var re = new RegExp("ab+c"); 使用构造函数，提供了对正则表达式运行时的编译。当你知道正则表达式的模式会发生改变， 或者你事先并不了解它的模式或者是从其他地方（比如用户的输入），得到的代码这时比较适合用构造函数的方式。 字符 含义 \ 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前面’\’的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。 反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a/ 代表会匹配 0 个或者多个 a。相反，模式 /a\/ 将 ‘‘ 的特殊性移除，从而可以匹配像 “a“ 这样的字符串。使用 new RegExp(“pattern”) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。 ^ 匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 $ 匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。 * 匹配前一个表达式0次或多次。等价于 {0,}。例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。 + 匹配前面一个表达式1次或者多次。等价于 {1,}。例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。 ? 匹配前面一个表达式0次或者1次。等价于 {0,1}。例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。还可以运用于向前断言，在本表格的 x(?=y) 和 x(?!y) 中有描述。 . （小数点）匹配除了换行符（\n）之外的任何单个字符。例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 x(竖线)y 匹配‘x’或者‘y’。例如，/green(竖线)red/匹配green apple”中的‘green’和“red apple”中的‘red’ {n} n是一个正整数，匹配了前面一个字符刚好发生了n次。比如，/a{2}/不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个’a’。 {n,m} n 和 m 都是正整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中得任意字符，匹配“candy”中得a，匹配“caandy”中得前两个a，也匹配“caaaaaaandy”中得前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。 \b 匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）例子：/\bm/匹配“moon”中得‘m’；/oo\b/并不匹配”moon”中得’oo’，因为’oo’被一个词汇字符’n’紧跟着。/oon\b/匹配”moon”中得’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个词汇字符紧跟着。/\w\b\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着。 \d 匹配一个数字。等价于[0-9]。例如， /\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。 \D 匹配一个非数字字符。等价于[^0-9]。例如， /\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。 \s 匹配一个空白字符，包括空格、制表符、换页符和换行符。例如, /\s\w*/ 匹配”foo bar.”中的’ bar’。 \S 匹配一个非空白字符。例如， /\S\w*/ 匹配”foo bar.”中的’foo’。 \w 匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。例如, /\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。 \W 匹配一个非单字字符。等价于[^A-Za-z0-9]。例如, /\W/ 或者 /[^A-Za-z0-9]/ 匹配 “50%.” 中的 ‘%’。 使用正则表达式使用正则表达式的方法 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。 使用括号的子字符串匹配一个正则表达式模式使用括号，将导致相应的子匹配被记住。例如，/a(b)c /可以匹配字符串“abc”，并且记得“b”。回调这些括号中匹配的子串，使用数组元素[1],……[n]。 使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。下面的例子说明了如何使用括号的子字符串匹配。 下面的脚本使用replace()方法来转换字符串中的单词。在匹配到的替换文本中，脚本使用替代的$ 1,$ 2表示第一个和第二个括号的子字符串匹配。 1234var re = /(\w+)\s(\w+)/;var str = "John Smith";var newstr = str.replace(re, "$2, $1");console.log(newstr); 这个表达式输出 “Smith, John” 通过标志进行高级搜索正则表达式有四个可选参数进行全局和不分大小写搜索。这些参数既可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。 123var re = /\w+\s/g;//可以替换成var re = new RegExp("\\w+\\s", "g"); 示范123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384[] 1.表示的是范围, 2.可以把关键性的元字符的本意干掉[0-9] 表示的是一个范围, 0到9所有的数字(包括0包括9)中的一个[3-7] 包括3，也包括7，之间所有的数字中的一个[a-z] 所有的小写字母[A-Z] 所有的大写字母[a-h] a到h之间所有的小写字母,包括a,也包括h 一个请写一个正则表达式 匹配所有的字母中 [a-zA-Z] - 范围表示所有的数字和所有的字母 [0-9a-zA-Z]() 1.提升优先级别 ,2.提取分组:一对括号就是一组( [0-9]([a-z][A-Z]))[0-9]谁是第一组，谁是第二组小括号提取的组,是从左开始算的| 或者的意思 优先级别最低. 除了\n以外的任意的一个单个的字符[] 表示范围可以把正则表达式中特殊含义的元字符的本意干掉[.] 就是一个.[-] 就是一个-. 除了\n以外的任意的一个单个字符[] 范围[0-9][a-z][A-Z][b] b*表示的是前面的这个表达式出现了0次到多次举例子: [0-9][a-z]*+ 表示的是前面的这个表达式出现了 1次到多次举例子: [a-z][0-9]+ &quot;af4&quot;? 表示的是前面的这个表达式出现了 0次到1次举例子: [0-9]? &quot;4545&quot;* + ? 可以看成是元字符中的限定符&#123;0,&#125; 表示的是前面的这个表达式出现了0次到多次 *&#123;0,1&#125; 表示的是前面的这个表达式出现了0次到 1次 ?&#123;1,&#125; 表示的是前面的这个表达式出现了1次到多次&#123;3,9&#125; 表示的是前面的这个表达式出现了3次到9次&#123;,4&#125; 这种写法是错误的举例子[a-z]&#123;4,9&#125; 小写字母最少除了4次特殊的:\d 表示的是任意的一个数字 和[0-9] 一样\D 表示的是非数字中的一个 &quot;f&quot;\s 表示的是空白符号 &quot; &quot;\S 非空白符号 &quot;fdf&quot; \w 非特殊符号 &quot;4&quot;\W 特殊符号 &quot;&amp;&quot;^ 1. 以什么开始 2.取反[^0-9] 取反了 (不是数字) ^[0-9] 以数字开头举例子 ^[0-9][a-z]$ 以什么结束 [0-9]$. 除了\n以外的任意一个单个的字符[]表示的范围,[0-9]单个一个数字,[a-z]单个的一个小写字母| 或者() 提升优先级 和分组* 前面的表达式出现了0次到多次+ 前面的表达式出现了1次到多次? 前面的表达式出现了0次到1次&#123;1,9&#125; 前面的表达式出现了1次到9次\d 一个任意数字\D 非数字\s 空白符号\S 非空白符号\w 非特殊符号\W 特殊符号(可以匹配中文)^ 以什么开头， 取反$ 以什么结束\b 单词的边界 hello are you no sha lei]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript声明提升和作用域]]></title>
      <url>%2F2015%2F02%2F02%2FJavaScript%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[在es6里面已经可以规避了声明的提升,但在es6之前包括严格模式下都会遇见声明提升带来的一些问题 变量定义 可以使用var定义变量，变量如果没有赋值，那变量的初始值为undefined. 如果没有使用var定义,那么就是隐式全局变量,此时全局都可以获得该变量,其作用域为全局 变量作用域变量作用域指变量起作用的范围。变量分为全局变量和局部变量。全局变量在全局都拥有定义；而局部变量只能在函数内有效。在函数体内，同名的局部变量或者参数的优先级会高于全局变量。也就是说，如果函数内存在和全局变量同名的局部变量或者参数，那么全局变量将会被局部变量覆盖。所有不使用var定义的变量都视为全局变量 变量运行（搜索）机制：首先看，有没有局部作用域如果有，查找是不是这个局部作用域定义的变量如果不是，寻找上一级作用域，直到找到全局作用域如果全局作用域也找不到这个变量，这个变量就是未定义的 undefined 函数作用域和声明提前JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是有定义的，也就是说变量在声明之前已经可用，所有这特性称为声明提前（hoisting），即JavaScript函数里的所有声明（只是声明，但不涉及赋值）都被提前到函数体的顶部，而变量赋值操作留在原来的位置。如下面例子：注释：声明提前是在JavaScript引擎的预编译时进行，是在代码开始运行之前。123456var scope = 'global';function f()&#123; console.log(scope); var scope = 'local'; console.log(scope);&#125; 由于函数内声明提升，所以上面的代码实际上是这样的1234567var scope = 'global';function f()&#123; var scope; //变量声明提升到函数顶部 console.log(scope); scope = 'local'; //变量初始化依然保留在原来的位置 console.log(scope);&#125; 变量声明 VS 函数声明 一般情况下,函数声明会覆盖变量声明。 但是如果在变量声明的同时，对变量进行初始化，情况会有所不同。对同一个变量名，声明变量同时初始化变量优先级高于函数声明。 12345var a = 1;function a() &#123; return true; &#125; console.log(a); //1 12345var a;function a()&#123; return true;&#125;console.log(a) //此时打印的是a的函数体 结论 变量声明提升：变量申明在进入执行上下文就完成了。 只要变量在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部； 函数声明提升：执行代码之前会先读取函数声明，意味着可以把函数声明放在调用它的语句后面。 只要函数在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部； 变量or函数声明：函数声明会覆盖变量声明，但不会覆盖变量赋值.同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。注意：如果在变量声明的同时初始化a，或是之后对a进行赋值，此时a的值变量的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组基本概念和原生方法]]></title>
      <url>%2F2015%2F01%2F18%2F%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[数组基本操作创建一个数组123var fruits = ["Apple", "Banana"];console.log(fruits.length);// 2 通过索引访问数组元素12345var first = fruits[0];// Applevar last = fruits[fruits.length - 1];// Banana 遍历一个数组12345fruits.forEach(function (item, index, array) &#123; console.log(item, index);&#125;);// Apple 0// Banana 1 属性 Array.prototype.constructor所有的数组实例都继承了这个属性，它的值就是 Array，表明了所有的数组都是由 Array 构造出来的。 Array.prototype.length上面说了，因为 Array.prototype 也是个数组，所有它也有 length 属性，这个值为 0，因为它是个空数组。 原生方法 下面的这些方法会改变调用它们的对象自身的值 Array.prototype.fill()将数组中指定区间的所有元素的值，都替换成某个固定的值。 语法:arr.fill(value[, start = 0[, end = this.length]]) 参数 value用来填充数组元素的值。 start可选，开始索引。 end可选，结束索引。 实例12345678[1, 2, 3].fill(4) // [4, 4, 4][1, 2, 3].fill(4, 1) // [1, 4, 4][1, 2, 3].fill(4, 1, 2) // [1, 4, 3][1, 2, 3].fill(4, 1, 1) // [1, 2, 3][1, 2, 3].fill(4, -3, -2) // [4, 2, 3][1, 2, 3].fill(4, NaN, NaN) // [1, 2, 3]Array(3).fill(4); // [4, 4, 4][].fill.call(&#123;length: 3&#125;, 4) // &#123;0: 4, 1: 4, 2: 4, length: 3&#125; Array.prototype.pop()删除数组的最后一个元素，并返回这个元素。 语法:array.pop() 描述 pop方法删除一个数组中的最后一个元素，并且把这个删除掉的元素返回给调用者。pop 被有意设计成具有通用性，该方法可以通过 call 或 apply 方法应用于一个类数组（array-like）对象上。 实例:下面的代码首先创建了一个拥有四个元素的数组 myFish，然后删除掉它的最后一个元素。 12345var myFish = ["angel", "clown", "mandarin", "surgeon"];console.log("myFish before: " + myFish);var popped = myFish.pop();console.log("myFish after: " + myFish);console.log("Removed this element: " + popped); Array.prototype.push()在数组的末尾增加一个或多个元素，并返回数组的新长度。 语法:arr.push(element1, …, elementN) 参数:elementN被添加到数组末尾的元素。 返回值当调用该方法时，新的 length 属性值将被返回。 实例 123456//添加元素到数组.下面的代码创建了 sports 数组，包含两个元素，然后又把两个元素添加给它。total 变量为数组的新长度值。var sports = ["soccer", "baseball"];var total = sports.push("football", "swimming");console.log(sports); // ["soccer", "baseball", "football", "swimming"]console.log(total); // 4 123456789//合并两个数组该示例使用 apply() 添加第二个数组的所有元素。var vegetables = ['parsnip', 'potato'];var moreVegs = ['celery', 'beetroot'];// Merge the second array into the first one// Equivalent to vegetables.push('celery', 'beetroot');Array.prototype.push.apply(vegetables, moreVegs);console.log(vegetables); // ['parsnip', 'potato', 'celery', 'beetroot'] Array.prototype.reverse()颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。 语法:arr.reverse() 描述:reverse 方法颠倒数组中元素的位置，并返回该数组的引用。 示例:12345//下例将会创建一个数组 myArray，其包含三个元素，然后颠倒该数组。var myArray = ['one', 'two', 'three'];myArray.reverse(); console.log(myArray) // ['three', 'two', 'one'] Array.prototype.shift()删除数组的第一个元素，并返回这个元素。 语法:arr.shift() 描述: shift 方法移除索引为 0 的元素(即第一个元素)，并返回被移除的元素，其他元素的索引值随之减 1。如果 length 属性的值为 0 (长度为 0)，则返回 undefined。shift 方法并不局限于数组：该方法亦可通过 call 或 apply 作用于对象上。对于不包含 length 属性的对象，将添加一个值为 0 的 length 属性。 实例1234567891011121314//移除数组中的一个元素.以下代码展示了 myFish 数组调用 shift 方法：var myFish = ['angel', 'clown', 'mandarin', 'surgeon'];console.log('调用 shift 之前: ' + myFish);// "调用 shift 之前: angel,clown,mandarin,surgeon"var shifted = myFish.shift(); console.log('调用 shift 之后: ' + myFish); // "调用 shift 之后: clown,mandarin,surgeon" console.log('被删除的元素: ' + shifted); // "被删除的元素: angel" Array.prototype.sort()对数组元素进行排序，并返回当前数组。 语法:arr.sort([compareFunction]) 参数:compareFunction可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的诸个字符的Unicode位点进行排序。 描述:如果没有指明 compareFunction，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。数字比大小时，9 出现在 80 之前，但这里比较时数字会先被转换为字符串，所以 “80” 比 “9” 要靠前。123456789101112var fruit = ['cherries', 'apples', 'bananas'];fruit.sort(); // ['apples', 'bananas', 'cherries']var scores = [1, 10, 2, 21]; scores.sort(); // [1, 10, 2, 21]// Watch out that 10 comes before 2,// because '10' comes before '2' in Unicode code point order.var things = ['word', 'Word', '1 Word', '2 Words'];things.sort(); // ['1 Word', '2 Words', 'Word', 'word']// In Unicode, numbers come before upper case letters,// which come before lower case letters. 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。记 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ，a和b的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003年之前的版本）； 如果 compareFunction(a, b) 大于 0 ，b会被排列到a之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 Array.prototype.splice()在任意的位置给数组添加或删除任意个元素。 Array.prototype.unshift()在数组的开头增加一个或多个元素，并返回数组的新长度。 下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。 Array.prototype.concat()返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。 语法:var new_array = old_array.concat(value1[, value2[, …[, valueN]]]) 参数:valueN 需要与原数组合并的数组或非数组值。 返回值:新的Array实例 描述: concat 方法将创建一个新的数组，然后将调用它的对象(this 指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组. concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里. 实例: 123456//下面的代码演示两个数组合并为一个新数组:var alpha = ["a", "b", "c"];var numeric = [1, 2, 3];// 组成新数组 ["a", "b", "c", 1, 2, 3]; 原数组 alpha 和 numeric 未被修改var alphaNumeric = alpha.concat(numeric); 1234567//下面的代码演示三个数组合并为一个新数组:var num1 = [1, 2, 3];var num2 = [4, 5, 6];var num3 = [7, 8, 9];// 组成新数组[1, 2, 3, 4, 5, 6, 7, 8, 9]; 原数组 num1, num2, num3 未被修改var nums = num1.concat(num2, num3); 12345//下面的代码演示将多个数组和多个非数组值合并为一个新数组:var alpha = ['a', 'b', 'c'];// 组成新数组 ["a", "b", "c", 1, 2, 3], 原alpha数组未被修改var alphaNumeric = alpha.concat(1, [2, 3]); Array.prototype.includes()判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。 语法:var boolean = array.includes(searchElement[, fromIndex]) 参数: searchElement需要查找的元素值。 fromIndex可选参数。从该索引处开始查找 searchElement，默认为 0。 返回值一个boolean 示例12345[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true Array.prototype.join()连接所有数组元素组成一个字符串。 语法: str = arr.join([separator = ‘,’]) 参数: separator可选，用于指定连接每个数组元素的分隔符。分隔符会被转成字符串类型；如果省略的话，默认为一个逗号。如果 seprator 是一个空字符串，那么数组中的所有元素将被直接连接。 描述:所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined 或者null， 则会转化成空字符串。 实例:例子: 使用四种不同的分隔符连接数组元素下例首先创建了一个数组 a，包含有三个元素，然后用四种不同的分隔符连接所有数组元素。首先是默认的分隔符逗号，然后是一个逗号加空格，接下来是一个加号前后加空格，最后是一个空字符串。12345var a = ['Wind', 'Rain', 'Fire'];var myVar1 = a.join(); // myVar1的值变为"Wind,Rain,Fire"var myVar2 = a.join(', '); // myVar2的值变为"Wind, Rain, Fire"var myVar3 = a.join(' + '); // myVar3的值变为"Wind + Rain + Fire"var myVar4 = a.join(''); // myVar4的值变为"WindRainFire" Array.prototype.slice()抽取当前数组中的一段元素组合成一个新数组。 语法:arr.slice([begin[,end]]) 参数: begin从该索引处开始提取原数组中的元素（从0开始）。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 0 开始。 end在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end的所有元素（包含begin，但不包含end）。 slice(1,4)提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。如果该参数为负数，则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1)表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果 end被省略，则slice会一直提取到原数组末尾。 返回值一个含有提取元素的新数组 描述:slice 不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。如果向两个数组任一中添加了新元素，则另一个不会受到影响。 实例: 1234567//返回数组中的一部分// Our good friend the citrus from fruits examplevar fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];var citrus = fruits.slice(1, 3);// puts --&gt; ["Orange","Lemon"] 12345678910111213141516171819202122232425262728//使用 slice.在下例中, slice从myCar中创建了一个新数组newCar.两个数组都包含了一个myHonda对象的引用. 当myHonda的color属性改变为purple, 则两个数组中的对应元素都会随之改变/ 使用slice方法从myCar中创建一个newCar.var myHonda = &#123; color: "red", wheels: 4, engine: &#123; cylinders: 4, size: 2.2 &#125; &#125;;var myCar = [myHonda, 2, "cherry condition", "purchased 1997"];var newCar = myCar.slice(0, 2);// 输出myCar, newCar,以及各自的myHonda对象引用的color属性.print("myCar = " + myCar.toSource());print("newCar = " + newCar.toSource());print("myCar[0].color = " + myCar[0].color);print("newCar[0].color = " + newCar[0].color);// 改变myHonda对象的color属性.myHonda.color = "purple";print("The new color of my Honda is " + myHonda.color);//输出myCar, newCar中各自的myHonda对象引用的color属性.print("myCar[0].color = " + myCar[0].color);print("newCar[0].color = " + newCar[0].color);//上述代码输出myCar = [&#123;color:"red", wheels:4, engine:&#123;cylinders:4, size:2.2&#125;&#125;, 2, "cherry condition", "purchased 1997"]newCar = [&#123;color:"red", wheels:4, engine:&#123;cylinders:4, size:2.2&#125;&#125;, 2]myCar[0].color = red newCar[0].color = redThe new color of my Honda is purplemyCar[0].color = purplenewCar[0].color = purple 123456789101112131415161718//类数组（Array-like）对象EDITslice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个数组。你只需将该方法绑定到这个对象上。下述代码中 list 函数中的 arguments 就是一个类数组对象。function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3]除了使用 Array.prototype.slice.call(arguments)，你也可以简单的使用 [].slice.call(arguments) 来代替。另外，你可以使用 bind 来简化该过程。var unboundSlice = Array.prototype.slice;var slice = Function.prototype.call.bind(unboundSlice);function list() &#123; return slice(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3] Array.prototype.toString()返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。 语法:arr.tostring() 对于数组对象，toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。例如，下面的代码创建了一个数组，然后使用 toString 方法把该数组转成一个字符串。 12var monthNames = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;];var myVar = monthNames.toString(); // assigns &quot;Jan,Feb,Mar,Apr&quot; to myVar. 注意:当一个数组被作为文本值或者进行字符串连接操作时，将会自动调用其 toString 方法。 Array.prototype.indexOf()返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 语法:arr.indexOf(searchElement[, fromIndex = 0]) 参数: searchElement 要查找的元素 fromIndex 开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。 如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0. 实例: 以下例子使用indexOf方法确定多个值在数组中的位置。 123456var array = [2, 5, 9];array.indexOf(2); // 0array.indexOf(7); // -1array.indexOf(9, 2); // 2array.indexOf(2, -1); // -1array.indexOf(2, -3); // 0 找出指定元素出现的所有位置 12345678910var indices = [];var array = ['a', 'b', 'a', 'c', 'a', 'd'];var element = 'a';var idx = array.indexOf(element);while (idx != -1) &#123; indices.push(idx); idx = array.indexOf(element, idx + 1);&#125;console.log(indices);// [0, 2, 4] Array.prototype.lastIndexOf()返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 语法:arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1]) 参数: searchElement被查找的元素。 fromIndex从此位置开始逆向查找。默认为数组的长度减 1，即整个数组都被查找。如果该值大于或等于数组的长度，则整个数组会被查找。如果为负值，将其视为从数组末尾向前的偏移。即使该值为负，数组仍然会被从后向前查找。如果该值为负时，其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。 实例: 下例使用 lastIndexOf 定位数组中的值。 12345678910111213var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3index = array.lastIndexOf(7);// index is -1index = array.lastIndexOf(2, 3);// index is 3index = array.lastIndexOf(2, 2);// index is 0index = array.lastIndexOf(2, -2);// index is 0index = array.lastIndexOf(2, -1);// index is 3 例子：查找所有元素 下例使用 lastIndexOf查找到一个元素在数组中所有的索引（下标），并使用 push 将所有添加到另一个数组中。 12345678910var indices = [];var array = ['a', 'b', 'a', 'c', 'a', 'd'];var element = 'a';var idx = array.lastIndexOf(element);while (idx != -1) &#123; indices.push(idx); idx = (idx &gt; 0 ? array.lastIndexOf(element, idx - 1) : -1);&#125;console.log(indices);// [4, 2, 0]; 在下面的众多遍历方法中，有很多方法都需要指定一个回调函数作为参数。在回调函数执行之前，数组的长度会被缓存在某个地方，所以，如果你在回调函数中为当前数组添加了新的元素，那么那些新添加的元素是不会被遍历到的。此外，如果在回调函数中对当前数组进行了其它修改，比如改变某个元素的值或者删掉某个元素，那么随后的遍历操作可能会受到未预期的影响。总之，不要尝试在遍历过程中对原数组进行任何修改，虽然规范对这样的操作进行了详细的定义，但为了可读性和可维护性，请不要这样做。 Array.prototype.forEach()为数组中的每个元素执行一次回调函数。 语法array.forEach(callback[, thisArg]) 参数 callback 函数为每个元素执行，接收三个参数： currentValue(当前值) 数组中正在处理的当前元素。 index(索引) 数组中正在处理的当前元素的索引。 array 正在应用forEach()数组。。 thisArg可选 可选参数。当执行回调 函数时用作this的值(参考对象)。 描述: forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括那些值为 undefined 的项）。 callback 函数会被依次传入三个参数： 数组当前项的值 数组当前项的索引 数组对象本身 如果给forEach传递了thisArg 参数，它将作为 callback 函数的执行上下文，类似执行如下函数callback.call(thisArg, element, index, array)。如果 thisArg 值为 undefined 或 null，函数的 this 值取决于当前执行环境是否为严格模式（严格模式下为 undefined，非严格模式下为全局对象）。 forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。 注意: 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。 实例: 下面的代码会为每一个数组元素输出一行记录：12345678function logArrayElements(element, index, array) &#123; console.log("a[" + index + "] = " + element);&#125;[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 9 Array.prototype.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。 语法 arr.every(callback[, thisArg]) 参数 callback用来测试每个元素的函数。 thisArg执行 callback 时使用的 this 值。 描述 every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。 callback 被调用时传入三个参数：元素值，元素的索引，原数组。 如果为 every 提供一个 thisArg 参数，在该参数为调用 callback 时的 this 值。如果省略该参数，则 callback 被调用时的 this 值，在非严格模式下为全局对象，在严格模式下传入 undefined。 every 不会改变原数组。 every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。 实例: 检测所有数组元素的大小.下例检测数组中的所有元素是否都大于 10。1234567function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true Array.prototype.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 12345678//逻辑类似于everyfunction isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is true Array.prototype.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 12345678//例子：筛选排除掉所有的小值下例使用 filter 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成。function isBigEnough(element) &#123; return element &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] Array.prototype.find()找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。 语法:arr.find(callback[, thisArg]) 参数 callback在数组每一项上执行的函数，接收 3 个参数： element当前遍历到的元素。 index当前遍历到的索引。 array数组本身。 thisArg可选，指定 callback 的 this 参数。 描述:find方法对数组中的每一项元素执行一次callback 函数，直至有一个callback返回true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回undefined。注意callback函数只会在分配了值的数组索引上调用，而不会在已删除或未分配值的索引上调用。 调用callback函数带有3个参数：当前元素的值、当前元素的索引，以及数组本身。 如果提供了thisArg参数，那么它将作为每次callback函数执行时的上下文对象，否则上下文对象为undefined。 find方法不会改变数组。 在第一次调用callback函数时会确定元素的索引范围，因此在find方法开始执行之后添加到数组的新元素将不会被callback函数访问到。如果数组中一个尚未被callback函数访问到的元素的值被callback函数所改变，那么当callback函数访问到它时，它的值是将是根据它在数组中的索引所访问到的当前值。被删除的元素不会被访问到。 实例12345678910111213//寻找数组中的质数//下面的例子展示了如何从一个数组中寻找质数（如果找不到质数则返回undefined）function isPrime(element, index, array) &#123; var start = 2; while (start &lt;= Math.sqrt(element)) &#123; if (element % start++ &lt; 1) &#123; return false; &#125; &#125; return element &gt; 1;&#125;console.log([4, 6, 8, 12].find(isPrime)); // undefined, not foundconsole.log([4, 5, 8, 12].find(isPrime)); // 5 Array.prototype.map()返回一个由回调函数的返回值组成的新数组。 语法:array.map(callback[, thisArg]) 参数 callback原数组中的元素经过该方法后返回一个新的元素。 currentValuecallback 的第一个参数，数组中当前被传递的元素。 indexcallback 的第二个参数，数组中当前被传递的元素的索引。 arraycallback 的第三个参数，调用 map 方法的数组。 thisArg 执行 callback 函数时 this 指向的对象。 返回值由回调函数的返回值组成的新数组。 描述 map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。 callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。 如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。 map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。 使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。 实例 求数组中每个元素的平方根下面的代码创建了一个新数组，值为原数组中对应数字的平方根。123var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);/* roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] */ 兼容性ES5中新增的数组方法，如下：123456789forEach (js v1.6)map (js v1.6)filter (js v1.6)some (js v1.6)every (js v1.6)indexOf (js v1.6)lastIndexOf (js v1.6)reduce (js v1.8)reduceRight (js v1.8) 以上数组方法有兼容性问题,需要注意]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 流程语句]]></title>
      <url>%2F2014%2F11%2F10%2FJavaScript%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5%2F</url>
      <content type="text"><![CDATA[循环语句 while 语法 123while(条件表达式)&#123; 循环执行代码段 &#125; 流程 判断条件表达式的值 当值为true时循环执行代码段 当值为false时退出循环体 特性 先检查条件，再执行循环 条件不满足则循环一次也不执行 时机 一个动作被重复执行到满足某个条件时 do-while 语法 123do&#123; 循环执行代码段&#125;while(条件表达式); 流程 先执行循环体内代码再进行判断 如果表达式的值为true，则循环执行代码段 如果表达式为false，则退出循环体 特性 先执行循环体，在进行条件判断 循环体内代码至少执行一次 时机 希望一个动作至少被执行一次时 for 语法 123for(循环变量 = 初值; 循环条件; 递增/递减计数器)&#123; 循环代码段&#125; 流程 用循环变量初始值与循环条件相比较，确定返回值 如果返回值为true则执行循环体 执行完一次后进行递增/递减运算 将运算结果与循环条件相比较 如果返回值为true则继续执行循环体；如果返回值为false则退出循环 时机 重复一个动作到一定次数 for-in(遍历无序对象,例如对象属性集合等等) 语法 123for( var 变量 in 对象)&#123; 代码段 &#125; 作用 枚举对象属性 注意事项 循环输出的属性顺序不可预知 对象的值不能是null或undefined 跳转语句 return 终止函数体的运行，并返回一个值 break 终止整个循环，不再进行判断 continue 结束本次循环，接着去判断是否可执行下次循环 选择语句 if 语法 1234567if( 条件表达式 )&#123; 代码段1&#125; else if( 条件表达式2)&#123; 代码段2&#125; else &#123; 代码段3&#125; 流程 判断条件1，如果返回值为true则执行代码段1 如果条件1的值为false则跳过代码段1并检测条件2 如果所有条件表达式的值为false则执行else后面的代码段3 特性 结构复杂，可嵌套 可测试多个条件表达式 表达式的值具有线性特征 表达式的值是动态的 适用于任意类型的数据 可处理复杂的逻辑关系 switch 语法 123456789switch(条件表达式)&#123; case 标签1: 代码段1; break; case 标签 2: 代码段2; break;//......default: 代码段n;&#125; 流程 计算表达式的值，并与各标签相比较 若找到与之匹配的标签，则执行其后的代码段 若没有找到，则直接执行default后的代码段 格式 case标签为常量，可以是字符串或数字 虽然break和default为可选项，但为了逻辑清晰最好不要省略 case标签的值必须和条件表达式的值完全匹配（===） 特性 结构简洁，专为多重选择设计 仅可测试一条条件表达式 表达式的值具有离散型 表达式的值是固定的，不会动态变化 仅能应用整数，枚举，字符串等类型数据 仅能处理多个枚举型逻辑关系 异常处理 throw 主动抛出异常 try 指明需要处理的代码段 catch 捕获异常 finally 后续处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript DOM操作]]></title>
      <url>%2F2014%2F10%2F20%2FJavaScript%20DOM%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[概念 DOM是javascript操作网页的接口，全称为文档对象模型(Document Object Model)。它的作用是将网页转为一个javascript对象，从而可以使用javascript对网页进行各种操作(比如增删内容)。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点(node)，文档的树形结构(DOM树)由12种类型的节点组成 一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。节点类型不同，这三个属性的值也不相同 节点属性 nodeType 属性返回节点类型的常数值。不同的类型对应不同的常数值，12种类型分别对应1到12的常数值 123456789101112元素节点 Node.ELEMENT_NODE(1)属性节点 Node.ATTRIBUTE_NODE(2)文本节点 Node.TEXT_NODE(3)CDATA节点 Node.CDATA_SECTION_NODE(4)实体引用名称节点 Node.ENTRY_REFERENCE_NODE(5)实体名称节点 Node.ENTITY_NODE(6)处理指令节点 Node.PROCESSING_INSTRUCTION_NODE(7)注释节点 Node.COMMENT_NODE(8)文档节点 Node.DOCUMENT_NODE(9)文档类型节点 Node.DOCUMENT_TYPE_NODE(10)文档片段节点 Node.DOCUMENT_FRAGMENT_NODE(11)DTD声明节点 Node.NOTATION_NODE(12) 获取节点类型的语法：nodeObject.nodeType其中，nodeObject为DOM节点（节点对象）。该属性返回以数字表示的节点类型，例如，元素节点返回 1，属性节点返回 2 。 例如，获取id=”demo”的标签的节点类型： document.getElementById(“demo”).nodeType;该语句的返回值为 1 。 举例，获取元素节点和文本节点的类型值：123456789101112&lt;div id="demo1"&gt;点击这里显示节点类型&lt;/div&gt;&lt;script type="text/javascript"&gt; document.getElementById("demo1").onclick=function()&#123; var divType=this.nodeType; var textType=this.firstChild.nodeType; //this指当前发生事件的HTML元素，这里是&lt;div&gt;标签 alert( "&lt;div&gt;标签的节点类型是："+divType+"\n"+ "&lt;div&gt;标签内部文本的节点类型是："+textType ); &#125;&lt;/script&gt; nodeName nodeName属性返回节点的名称 节点名称就是DOM节点的名字，不同类型的节点对应不同的节点名称。 12345节点类型 节点名称元素节点 HTML标签的名称（大写）属性节点 属性的名称文本节点 它的值永远是#text文档节点 它的值永远是#document 获取节点名称的语法：nodeObject.nodeName其中，nodeObject 为DOM节点（节点对象）。 例如，获取id=”demo”的标签的节点名称：document.getElementById(“demo”).nodeName;该语句的返回值为 DIV 。 举例，获取元素节点名称、文本节点名称和文档节点名称：1234567891011121314&lt;div id="demo2"&gt;点击这里显示节点名称&lt;/div&gt;&lt;script type="text/javascript"&gt; document.getElementById("demo2").onclick=function()&#123; var divName=this.nodeName; var textName=this.firstChild.nodeName; //this指当前发生事件的HTML元素，这里是&lt;div&gt;标签 var documentName=document.nodeName alert( "&lt;div&gt;标签的节点名称是："+divName+"\n"+ "&lt;div&gt;标签内部文本的节点名称是："+textName+"\n"+ "文档节点的节点名称是："+documentName ); &#125;&lt;/script&gt; nodeValue nodeValue属性返回或设置当前节点的值，格式为字符串 对于文本节点，节点值为文本内容；对于属性节点，节点值为属性的值。 节点值对于文档节点和元素节点是不可用的。 获取节点值的语法：nodeObject.nodeValue其中，nodeObject 为DOM节点（节点对象）。 举例，获取文本节点的节点值：1234567&lt;div id=&quot;demo3&quot;&gt;点击这里显示文本节点的值&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById(&quot;demo3&quot;).onclick=function()&#123; alert(this.firstChild.nodeValue); //this指当前发生事件的HTML元素，这里是&lt;div&gt;标签&#125;&lt;/script&gt; 获取节点 document getElementById() 语法 document.getElementById(元素id); 功能 通过元素id获取节点 类型 dom元素 getElementsByName() 语法 document.getElementsByName(元素name属性); 功能 通过元素的name属性获取节点 类型 HTMLCollection伪数组对象 getElementsByTagName() 语法 document.getElementsByTagName(元素标签名) 功能 通过元素的标签名字获取节点 类型 HTMLCollection伪数组对象 节点指针 firstChild 语法 父节点.firstChild 功能 获取元素的首个子节点 lastChild 语法 父节点.lastChild 功能 获取元素的最后一个子节点 childNodes 语法 父节点.childNodes 功能 获取元素的子节点列表 previousSibling 语法 兄弟节点.previousSibling 功能 获取指定节点的前一个兄弟节点 nextSibling 语法 兄弟节点.nextSibling 功能 获取指定节点的下一个兄弟节点 parentNode 语法 子节点.parentNode 功能 获取指定节点的父节点节点操作 创建节点 createElement() 语法 document.createElement(元素标签名); 功能 通过标签名字创建元素节点 createAttribute() 语法 document.createAttribute(元素属性名); 功能 创建属性节点 createTextNode() 语法 document.createTextNode(文本内容) 功能 创建文本节点 插入节点 appendChild() 语法 父节点.appendChild(newNode); 功能 向节点的子节点列表的末尾添加新子节点 insertBefore() 语法 父节点.insertBefore(newNode, 已知节点); 功能 在已知节点之前添加新子节点 替换节点 replaceChild() 语法 parentNode.replaceChild(newNode, oldNode); 功能 将某个子节点替换另一个 复制节点 cloneNode() 语法 需要被复制节点.cloneNode(true/false); 功能 创建节点的副本 参数 true深克隆 克隆当前节点及其所有子节点 false浅克隆 仅克隆当前节点 删除节点 removeChild() 语法 parentNode.removeChild(delNode); 功能 删除指定节点属性操作 获取属性 getAttribute() 语法 元素节点.getAttribute(元素属性名); 功能 获取元素节点中指定属性的属性值 设置属性 setAttribute() 语法 元素节点.setAttribute(属性名, 属性值); 功能 创建或改变元素节点的属性 删除属性 removeAttribute() 语法 元素节点.removeAttribute(属性名); 功能 删除元素中指定属性 文本操作 insertData(offset, string) 从offset指定的位置插入string appendData(string) 将string插入到文本节点的末尾处 deleteData(offset, count) 从offset起删除count个字符 replaceData(off, count, string) 从off将count个字符用string来替换 splitData(offset) 从offset起将文本节点分成两个节点 substring(offset,count) 返回由offset起的count个节点 附录-节点总结 元素节点 元素节点element对应网页的HTML标签元素。 元素节点的节点类型nodeType值是1 节点名称nodeName值是大写的标签名 nodeValue值是null 123// 以body元素为例console.log(document.body.nodeType,document.body.nodeName,document.body.nodeValue)console.log(Node.ELEMENT_NODE === 1);//true 特性节点 元素特性节点attribute对应网页中HTML标签的属性,它只存在于元素的attributes属性中，并不是DOM文档树的一部分。 特性节点的节点类型nodeType值是2 节点名称nodeName值是属性名 nodeValue值是属性值12345678//现在，div元素有id=&quot;test&quot;的属性&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script&gt;var attr = test.attributes.id;//2 &apos;id&apos; &apos;test&apos;console.log(attr.nodeType,attr.nodeName,attr.nodeValue)console.log(Node.ATTRIBUTE_NODE === 2);//true &lt;/script&gt; 文本节点 文本节点text代表网页中的HTML标签内容。 文本节点的节点类型nodeType值是3 节点名称nodeName值是’#text’ nodeValue值是标签内容值12345678//div元素内容为&apos;测试&apos;&lt;div id=&quot;test&quot;&gt;测试&lt;/div&gt;&lt;script&gt;var txt = test.firstChild;//3 &apos;#text&apos; &apos;测试&apos;console.log(txt.nodeType,txt.nodeName,txt.nodeValue)console.log(Node.TEXT_NODE === 3);//true &lt;/script&gt; CDATA节点 CDATASection类型只针对基于XML的文档，只出现在XML文档中，表示的是CDATA区域，格式一般为&lt;![CDATA[]]&gt; 该类型节点的节点类型nodeType的值为4 节点名称nodeName的值为’#cdata-section’ nodevalue的值是CDATA区域中的内容 实体引用名称节点 实体是一个声明，指定了在XML中取代内容或标记而使用的名称。 实体包含两个部分，首先，必须使用实体声明将名称绑定到替换内容。 实体声明是使用 &lt;!ENTITY name &quot;value&quot;&gt; 语法在文档类型定义(DTD)或XML架构中创建的。其次，在实体声明中定义的名称随后将在 XML 中使用。 在XML中使用时，该名称称为实体引用。 实体引用名称节点entry_reference的节点类型nodeType的值为5 节点名称nodeName的值为实体引用的名称 nodeValue的值为null 1234//实体名称&lt;!ENTITY publisher &quot;Microsoft Press&quot;&gt;//实体名称引用&lt;pubinfo&gt;Published by &amp;publisher;&lt;/pubinfo&gt; 实体名称节点 上面已经详细解释过，就不再赘述 该节点的节点类型nodeType的值为6 节点名称nodeName的值为实体名称 nodeValue的值为null 处理指令节点 处理指令节点ProcessingInstruction的节点类型nodeType的值为7 节点名称nodeName的值为target nodeValue的值为entire content excluding the target 注释节点 注释节点comment表示网页中的HTML注释。 注释节点的节点类型nodeType的值为8 节点名称nodeName的值为’#comment’ nodeValue的值为注释的内容 12345678现在，在id为myDiv的div元素中存在一个&lt;!-- 我是注释内容 --&gt;&lt;div id=&quot;myDiv&quot;&gt;&lt;!-- 我是注释内容 --&gt;&lt;/div&gt;&lt;script&gt;var com = myDiv.firstChild;//8 &apos;#comment&apos; &apos;我是注释内容&apos;console.log(com.nodeType,com.nodeName,com.nodeValue)console.log(Node.COMMENT_NODE === 8);//true &lt;/script&gt; 文档节点 文档节点document表示HTML文档，也称为根节点，指向document对象。 文档节点的节点类型nodeType的值为9 节点名称nodeName的值为’#document’ nodeValue的值为null 12345&lt;script&gt;//9 &quot;#document&quot; nullconsole.log(document.nodeType,document.nodeName,document.nodeValue)console.log(Node.DOCUMENT_NODE === 9);//true &lt;/script&gt; 文档类型节点文档类型节点DocumentType包含着与文档的doctype有关的所有信息。 文档类型节点的节点类型nodeType的值为10 节点名称nodeName的值为doctype的名称 nodeValue的值为null 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;var nodeDocumentType = document.firstChild;//10 "html" nullconsole.log(nodeDocumentType.nodeType,nodeDocumentType.nodeName,node DocumentType.nodeValue);console.log(Node.DOCUMENT_TYPE_NODE === 10);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文档片段节点 文档片段节点DocumentFragment在文档中没有对应的标记，是一种轻量级的文档，可以包含和控制节点，但不会像完整的文档寻亲战胜额外的资源。 该节点的节点类型nodeType的值为11 节点名称nodeName的值为’#document-fragment’ nodeValue的值为null 123456&lt;script&gt;var nodeDocumentFragment = document.createDocumentFragment(); //11 "#document-fragment" nullconsole.log(nodeDocumentFragment.nodeType,nodeDocumentFragment.nodeName,nodeDocumentFragment.nodeValue);console.log(Node.DOCUMENT_FRAGMENT_NODE === 11);//true&lt;/script&gt; DTD声明节点 DTD声明节点notation代表DTD中声明的符号。 该节点的节点类型nodeType的值为12 节点名称nodeName的值为符号名称 nodeValue的值为null]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[美丽的交错]]></title>
      <url>%2F2014%2F09%2F28%2F%E7%BE%8E%E4%B8%BD%E7%9A%84%E4%BA%A4%E9%94%99%2F</url>
      <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记得我以前说过：有些人，有些事，就如两条平行线一般，只能相望，却永远不会交集。不过，还有些人，会是两条相交的直线，在前一刻我们彼此不知道对方，陡然相遇，手足无措，一起走过难忘的一段日子，然后倏然相离，随着时间的流逝，越来越远，从相知到相望，最后也许连音容笑貌，也淡去了，只剩下那份感觉。就像流星一样，划过天空，留下浅浅的痕迹。也许，我们就是这样。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我很快又会投身于紧张而又忙碌的生活，在繁忙中淡淡地一点点地忘记这一切。记忆手中的沙砾，抓住一把，却总会渐渐流逝，越是用力，越是消逝。半个月的日子里，很遗憾，没能一直带你们到最后。很遗憾，不能让每个人都上场。而当日子一天天过去的时候，我总会想起离别的日子又会如何。人的一生总会遇到很多人，大多数人，只是过客。一些人，会停留一段时间，只有极少的人会留下陪你走过。所以啊，告别的时候一定要多用力一点，因为你不知道这多看的这一眼，是不是就是最后一眼。这多说的这一句话，可能就是最后一句话。我欠下了多少应该用力的告别，每次我们都抱着“还会相遇”的想法说着再见，却总是再也不见。如果知道那是最后一眼、最后一句，我想我一定会想要重新来过。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;孩子们，现在的不舍只是一时的不习惯。随着岁月的流淌，我们总是得不断地习惯分离。有的，是暂时的。有的，就是永远。也许多年后，回想当初，只会记得，曾经有过这么一帮人，和我在操场上，一起晒太阳，一起努力。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每件难忘的事情，就像路上的一盏明灯。当我在前进的道路上驻足不前，回望过来的路，总会看见那么几盏明灯，它们是我人生的写照，激励我继续向前。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;交错是一种遗憾，因为遗憾，所以美丽。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript运算符]]></title>
      <url>%2F2014%2F09%2F28%2FJavaScript%20%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[算术运算符 “+”运算符 功能 对数字进行代数求和 对字符串进行拼接操作 将数值转换成字符串数值+空字符串 字符串拼接 字符串 + 字符串二者直接拼接 字符串 + 数值 或 数值 + 字符串将数值转换成字符串，再拼接 “-“运算符 功能 单目运算符对操作数进行“取反”操作 减法对两个运算数进行减法运算 将字符串转换成数值数值型字符串 - 0 “*”运算符 功能 对两个运算数进行乘法运算 正/负 同号得正，异号得负 “/“运算符 功能 对两个运算数进行除法运算 正/负 同号得正，异号得负 “%”运算符 功能 对两个运算数进行求余运算+ 正/负 与第一个运算数的符号相同 复合赋值运算符 +=、-=、*=、/=、%= 自增 / 自减 功能 “++”对运算数进行递增操作（每次+1） “–”对运算数进行递减操作（每次-1） 规则 运算数必须是一个变量，数组中的一个元素或者对象的属性 如果运算数是非数值，则自动转换成数值 符号位置决定运算结果 运算数之前先执行递增（递减）运算，再求值 运算数之后先求值，再执行递增（递减运算） 关系运算符 大小关系 运算符 “&lt;”运算符if A 小于 B，返回值为true；否则为false “&lt;=”运算符if A 小于或等于 B，返回值为true；否则为false “&gt;”运算符if A 大于 B，返回值为true；否则为false “&gt;=”运算符if A 大于或等于 B，返回值为true；否则为false 规则 数值与数值比较比较它们的代数值 仅一个运算数为数值将另一个运算数转换为数值，并比较它们的代数值 字符串间比较逐字符比较它们的Unicode数值 字符串与非数值比较将其转换成字符串并进行比较 运算数为非数字也非字符串转换成数值或字符串进行比较 运算数无法转换成数值或字符串返回值为false 与NaN的比较返回值为false 等值关系 相等比较 运算符 “==”比较两个运算数的返回值是否相等 “!=”比较两个运算数的返回值是否不相等 类型转换 bool值true =&gt; 1false =&gt; 0 对象调用valueOf() 基本数据类型 字符串与数值字符串转换成数值 比较原则 null 与 undefined 相等 比较前不进行任何转换 NaN 与任何数值都不相等包括自身 对象 是否属于同一对象 是引用值相等 否引用值不等 相同比较 运算符 “===”比较两个运算数的返回值以及数据类型是否相同 “!==”比较两个运算数的返回值以及数据类型是否不同 比较原则 值类型间比较只有数据类型相同且数值相等时，返回值为true 值类型与引用类型比较肯定不同 ，返回值为false 引用类型间比较比较它们的引用值（内存地址） 对象运算符 in判断左侧运算数（string）是否为右侧运算数（object）的成员 instanceof判断左侧实例是否属于右侧类或构造函数 new根据构造函数创建一个新的对象，并初始化该对象 delete删除指定对象的属性、数组元素或变量 .及[]存取对象和数组元素 ()函数调用，改变运算符优先级 逻辑运算符 ! 逻辑非 返回值 true 空字符串 0 null NaN undefined false 对象 非空字符串 非0数值（Infinity） 特性 如果运算数的值为false，则返回true，否则返回false 连续使用两次!，可将任意类型转为布尔型值 &amp;&amp;逻辑与 规则 第一个运算数是对象,返回第二个运算数 第二个运算数是对象,第一个运算数值为true时，返回该对象；否则返回第一个运算数 两个运算数都是对象,返回第二个运算数 一个运算数为null,返回null 一个运算数为NaN,返回NaN 一个运算数为undefined,返回undefined 特性 当且仅当两个运算数的值都是true时，才返回true，否则返回false 短路操作当有一个运算数的值为false则直接返回，不会再继续运算下去 ||逻辑或 规则 第一个运算数是对象,返回第一个运算数 第二个运算数值是false,返回第二个运算数 两个运算数都是对象,返回第一个运算数 两个运算数为null,返回null 两个运算数为NaN,返回NaN 两个运算数为undefined,返回undefined 特性 当且仅当两个运算数的值都为false才会返回false，否则返回true 短路操作如果有一个运算数值为true，则返回此运算数，不会再继续运算下去 位运算符 基础知识 类型 有符号 数值位:前31位 符号位:第32位 0 正数 1 负数 无符号 只能是正数 第32位表示数值 数值范围加大 数值范围-2147483648 ~ 2147483647 存储方式 正数 纯2进制存储 31位中每一位表示2的幂 用0补充无用位 负数 2进制补码存储 补码的计算步骤 确定该数字的非负版本的二进制表示 求得2进制反码，即要把0替换为1，把1替换成0 在2进制反码上加1 当0处理的特殊值 NaN Infinity 逻辑位运算 返回值为1 按位非~ 0 按位与&amp; 对应位全为1 按位或| 任何一位是1 按位异或^ 既不同时为0，也不同时为1 返回值为0 按位非~ 1 按位与&amp; 任意一位是0 按位或| 对应位都是0 按位异或^ 对应位全0或全1 位移操作 左移&lt;&lt; 将数值的所有位左移指定的位数 所有空位用0补充 左移1位其乘2，左移2位对其乘4，以此类推 有符号右移 将数值的所有位右移指定的位数 移出的位被舍弃 保留符号位 右移1位对其除2，右移2位对其除4，以此类推 无符号右移 正数与有符号右移结果相同 负数会出现无限大的数值 复合赋值运算符位运算符与=结合，复合赋值不会有性能方面的提升 其他运算符 ?: (三元运算)条件运算符，简洁的if else typeof类型判定运算符 ,逗号，在一行语句中执行多个不同的操作 void舍弃运算数的值，返回undefined作为表达式的值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS总结]]></title>
      <url>%2F2014%2F07%2F12%2FCSS%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[常见属性 属性 解释 书写规范 width 宽度 width:300px height 高度 height:300px color 文本颜色 color:red Background-color 背景颜色 background-color:green font-size 文字大小 font-size:34px Text-align 内容的水平对齐方式 text-align:left/center/right Text-indent 首行缩进 Text-indent:2em 选择器 基础选择器: 标签选择器 作用：给指定的标签添加样式。1标签名&#123; 属性:值;属性:值 &#125; 类选择器(重点) 注意 不能使用纯数字或者数字加英文来命名类名称。 不推荐使用汉字来给类命名。 不能以特殊符号给命名（_除外）。 不推荐使用标签代码或者样式的属性来命名类名称。1.自定义类名&#123;属性:值;属性:值&#125; id选择器 特点： 一个页面只能调用一次，ID选择器配合JS使用。 一个标签只能调用一个ID选择器。1#自定义id名&#123;属性:值;属性:值&#125; 通配符选择器 含义:*代表所有标签，会给所有的标签加上样式。会增加服务器和浏览器压力，不推荐使用。1*&#123;属性:值;属性:值&#125; 复合选择器 交集选择器（标签指定式选择器） 关系：即…又…,既要满足标签，还要满足标签后边的样式文件。123标签.自定义类名&#123;属性:值;&#125;标签#自定义id&#123;属性:值;&#125;.自定义类名#自定义id&#123;属性:值;&#125; 后代选择器（重点） 特点: 必须是包含关系，父元素选择器写在前，子元素选择器写在后，通过空格链接在一起。 标签选择器、类选择器、ID选择器可以自由组合，只要能代表父子关系即可。 只要能代表父子，可以无限制的隔代。 1选择器+空格+选择器+空格+....选择器&#123;属性:值;&#125; 并集选择器 特点：可以是标签选择器、类选择器、ID选择器、后代选择器、交集选择器通过逗号自由组合在一起。1选择器1,选择器2,选择器3 &#123;属性:值;&#125; h5新增(IE8以上支持) querySelector(标签,类名,id等等皆可) 该方法返回满足条件的单个元素。按照深度优先和先序遍历的原则使用参数提供的CSS选择器在DOM进行查找，返回第一个满足条件的元素。12element = document.querySelector('div#container');//返回id为container的首个divelement = document.querySelector('.foo,.bar');//返回带有foo或者bar样式类的首个元素 querySelectorAll 该方法返回所有满足条件的元素，结果是个nodeList集合。查找规则与前面所述一样。 1elements = document.querySelectorAll('div.foo');//返回所有带foo类样式的div 注意:但需要注意的是返回的nodeList集合中的元素是非实时（no-live）的，想要区别什么是实时非实时的返回结果 1234567891011&lt;div id=&quot;container&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;//首先选取页面中id为container的元素container=document.getElementById(&apos;#container&apos;);console.log(container.childNodes.length)//结果为2//然后通过代码为其添加一个子元素container.appendChild(document.createElement(&apos;div&apos;));//这个元素不但添加到页面了，这里的变量container也自动更新了console.log(container.childNodes.length)//结果为3 书写位置 书写位置 外链式 新建一个文件，后缀名以.css命名（css文件）在html页面中通过&lt;link rel=&#39;stylesheet&#39; href=&#39;&#39;&gt; 标签将css文件引入 内嵌式 直接写在head标签里 行内式 通过给标签设置style属性来设置样式。 1&lt;p style="color:red"&gt;文字&lt;/p&gt; 书写方式的区别 内嵌式写法： 代码可维护性较差，没有实现css代码与html结构的完全分离 影响的范围只有当前页面 行内式写法： 代码可维护性极差，css代码和html结构没有实现分离 影响的范围只有当前标签 外联式写法： 代码可维护性高，css与html结构完全分离 影响范围广，当前整个网页站点。 css特性 层叠性 样式的覆盖。 样式的层叠性与样式的调用顺序没有关系，与样式的定义顺序有关。 层叠性发生的前提： 样式冲突 继承性 继承性发生的前提是标签之间属于一种嵌套关系 文字颜色可以实现继承 文字大小可以实现继承 字体可以实现继承 行高可以实现继承 与文字有关的属性都可以 实现继承 特殊性： a标签不能继承父元素中的文字颜色（层叠掉了） 标题标签不能继承父元素中的文字大小 优先级 默认样式&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;!important 权重会叠加,但是同级可比非同级不可比 伪类 a:link{属性:值;}超链接默认状态下的样式a{}与a:link{}实现的效果是一样的 a:visited{属性:值;}超链接访问过后的样式 a:hover{属性:值}鼠标放到超链接上的样式 a:active{属性:值}超链接激活状态下的样式 a:focus{属性:值}获取焦点（光标）的时候的样式 文字属性123//属性连写自定义样式名称&#123;font: font-style font-weight font-size/line-height font-family;&#125;//注意：按照顺序书写，文字大小和字体不能缺少，其余的根据需求写，书写是文字大小在前边，字体在后边。 背景（background） Background-color : 颜色名 background-image （背景图片）: 图片相对路径或者绝对路径 background-repeat（设置背景平铺） repeat （默认值） no-repeat （不平铺） repeat-x （横向平铺） repeat-y （纵向平铺） background-position （设置背景位置） 设置具体值： left| right| top| bottom| cneter 设置具体值的时候不区分先后顺序 设置具体数字的时候，第一个值代表水平方向，第二个值代表垂直方向 background-attachment （设置背景是否固定） scroll（默认值）滚动 fixed （图片固定） 属性联写：没有数量限制和先后顺序限制 background:url(“i.png ”red no-repeat 30px 40px) 行高 行高line-height 浏览器默认文字大小 浏览器默认文字大小为16px 行高=文字大小+上边距+下边距 行高定义 行高指的是文本基线与基线的距离。 行高的作用 当文字行高与父容器的高度一样的时候，文字垂直居中对齐。(常用于设置居中) 行高的单位问题 行高单位 赋值 文字大小 行高值 PX 30px 20px 30px em 3em 20px 60px % 150% 20px 30px 不带单位 2 20px 60px 总结：当给父元素设置行高的时候，除了以PX为单位以外，其他的值都与文字大小有关，是与文字大小的乘积。 行高是可以继承的 行高单位 设置行高 父文字 子文字 行高 px 40px 20px 30px 40px em 2em 20px 30px 40px % 120% 20px 30px 24px 不带单位 2 20px 30px 60px 总结：当父元素设置的行高值除了不带单位的情况下，都是先与父元素文字大小相乘，然后再被子元素继承。 盒子模型 Border border-width: 边框的粗细 border-style: 边框的风格 dotted: 点线 dashed: 虚线 solid: 实线 Border-color: 边框的颜色 连写的时候后边的值不分前后顺序。例如：border：1px solid red 等价于 border:red solid 5px 表格单元格合并 border-collapse:collapse; 表格单元格边框合并。 内边距(padding) Padding-left 左内边距 Padding-right 右内边距 Padding-top 上内边距 Padding-bottom 底内边距 内边距简写： Padding:10px; 四个方向内边距都为10px Padding: 10px 20px; 上下内边距为10px 左右内边距为20px Padding: 10px 20px 30px; 上内边距为10px 左右内边距为20px 下内边距为30px padding:10px 20px 30px 40px; 依次方向为上右下左 盒子宽度问题影响盒子宽度因素： 盒子边框影响盒子宽度 定义的内边距的宽度 盒子的宽度=定义的宽度+边框+内边距 注意：以后进行页面盒子布局的实现，如果给盒子设置了内边距和边框，对应的要将定义宽度或者高度减去定义的内边距和边框的值。 盒子大小影响特殊地方 继承的盒子再父盒子宽度范围内，padding值不会影响该盒子大小。外边距 当2个盒子垂直显示的时候，外边距发生了合并（重叠），那么外边距取的是定义的较大的值。 当2个盒子发生嵌套关系时，给子元素定义外边距的时候，值会赋给外边的大盒子。 解决外边距的塌陷 给大盒子定义边框 给外边大盒子设置:overflow:hidden; Bfc 给外边父集元素设置overflow:hidden，会触动bfc.浮动 用法:float:left|right 特点 浮动起来 不占位置（脱标） 如果多个盒子都使用了浮动，会在一行上显示。 给行内元素使用浮动，可将行内元素转换成行内块。 尽量用display转换行内块。 作用 文本绕图 制作导航栏 网页布局 清除浮动 额外标签法 在浮动元素后边加一个标签，清除浮动。 Overflow:hidden; 在外边的父盒子上使用：overflow:hidden;如果有内容在盒子外，会被裁掉。 伪元素清除浮动 12345678910.clearfix:after&#123; Content:”.”; Display:block; Height:0; Visibility:hidden; Clear；both; &#125; .clearfix&#123; Zoom:1; &#125; 定位 静态定位(Position:static;) 静态定位就是标准流。 绝对定位（position:absolute;） 特点 给元素设置绝对定位，从浏览器左上角出发设置位置。 给元素设置了绝对定位，元素会不占位置（脱标） 当盒子发生嵌套关系时，如果父集元素没有设置定位，子盒子设置了绝对定位并赋值，子盒子的位置从浏览器左上角出发。 当盒子发生嵌套关系时，如果父集元素设置了绝对定位，子盒子设置了绝对定位并赋值，子盒子的位置从父集元素左上角出发。 绝对定位会将行内元素，转换为行内块。 相对定位(position:relative;) 特点： 给元素设置了相对定位，位置是从自身位置出发。 给元素设置了相对定位，还占据原来的位置（不脱标）。 子绝父相（工作中使用最多），子元素绝对定位，父元素相对定位。 给元素设置相对定位，不能将行内元素转换为行内块元素。 固定定位（position:fixed;） 特点: 固定定位不占据原来的位置，会脱标。 给元素设置固定定位之后，元素位置从浏览器左上角出发。 可以将行内元素转换为行内块元素。 Overflow overflow:hidden 会将出了盒子的内容裁掉 overflow：auto; 当内容出了盒子之外，会自动生成滚动条，如果没有内容之外，则不生成滚动条。 overflow:scroll; 不管内容有没有出盒子，都会生成滚动条。 overflow: visible; 内容出了盒子会显示，不生成滚动条。（默认值） 其他 内容移除文字（logo优化） 用text-indent:-2000px; 用padding撑开盒子，使用overflow将文字隐藏。 图片与文字垂直对齐 Inline-block vertical-align默认为Vertical-align:baseline;配合行高去做 可见性 overflow:hidden; 将元素盒子之外的部分隐藏。 display:none; 将元素直接隐藏 display:block; 将元素显示 (配合JS使用） visibility:hidden; 将元素隐藏 display:none;隐藏之后不占位置。 visibility:hidden; 隐藏之后还占位置。 精灵图 Css精灵是一种处理背景图像的方式，可以加快网页的加载速度，降低服务器发送请求的次数 浏览器坐标：从浏览器左上角出发，向右为正，向下为正。Css精灵图配合background-position背景位置结合使用。 居中显示 盒子居中显示margin:0 auto; 只能让标准流的盒子居中显示。 定位的盒子居中显示写法：先向左走父集元素的一半，再向右走（margin-left用负值）自己的一半。 标签嵌套规范 div可以包含所有的标签。 p标签不能包含div、标题标签、列表标签。 h1可以包含其他标签。 不推荐在行内元素中放其他元素。]]></content>
    </entry>

    
  
  
</search>
